[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Genre et Identité: Pour vivre heureux, vivons normés?",
    "section": "",
    "text": "Introduction\nTRAVAIL EN COURS",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "construction_indice.html",
    "href": "construction_indice.html",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "",
    "text": "1.1 Indice Alternatif: Méthode de LASSO\ncode R\nsummary(my_data_frame$Library)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  1.0000  1.0000  0.8347  1.0000  1.0000 \n\n\ncode R\nmy_data_frame$SEXE&lt;-as.factor(my_data_frame$SEXE)\nreg_lm&lt;- lm(Sex~ Knitting+ \n                  Cards_games+  \n                  Gambling+ \n                  Cooking+ \n                  DIY+\n                  Vegetable_garden+ \n                  Ornamental_garden+  \n                  Fishing_hunting+ \n                  Collection+\n                  Vehicle_custom + \n                  Making_music +\n                  Diary +\n                  Writing +  \n                  Painting +  \n                  Montage + \n                  Circus +\n                  Pottery + \n                  Theater + \n                  Drawing + \n                  Dancing +  \n                  Photography +\n                  Genealogy + \n                  Science +\n                  None +\n                  No_Amateur +\n                  Video_games +\n                  TV +\n                  Radio+\n                  Library+\n                  Museums +  \n                  Internet + \n                  Concert, data=my_data_frame)\n\n\n\nn &lt;- nrow(my_data_frame)\n\n# Indices pour la division (2/3 pour l'entraînement, 1/3 pour le test)\ntrain_index &lt;- sample(1:n, size = 2 * n / 3)  # 2/3 des indices pour l'entraînement\n\n# Créer l'ensemble d'entraînement et l'ensemble de test\ntrain_data &lt;- my_data_frame[train_index, ]  # Enregistrement d'entraînement\ntest_data &lt;- my_data_frame[-train_index, ]  # Enregistrement de test\n\n# Vérifier les tailles\ncat(\"Nombre d'observations dans l'ensemble d'entraînement :\", nrow(train_data), \"\\n\")\n\n\nNombre d'observations dans l'ensemble d'entraînement : 6156 \n\n\ncode R\ncat(\"Nombre d'observations dans l'ensemble de test :\", nrow(test_data), \"\\n\")\n\n\nNombre d'observations dans l'ensemble de test : 3078 \n\n\ncode R\n# Charger les bibliothèques nécessaires\nlibrary(glmnet)\nlibrary(pROC)\n\n# Définir la matrice X pour l'entraînement\nx &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                  Vegetable_garden + Ornamental_garden + Fishing_hunting + \n                  Collection + Vehicle_custom + Making_music + Diary + Writing + \n                  Painting + Montage + Circus + Pottery + Theater + Drawing + \n                  Dancing + Photography + Genealogy + Science + None + No_Amateur +\n                  Video_games + TV + Radio + Library + Museums + Internet + Concert,\n                  train_data)[, -1]\n\n# Variable cible y pour l'entraînement\ny &lt;- train_data$SEXE\n\n# Ajuster le modèle LASSO avec validation croisée\ncv_lasso &lt;- cv.glmnet(x, y, alpha = 1, family = \"binomial\")\nbest_lambda &lt;- cv_lasso$lambda.min  # Lambda optimal\n\n# Vérifie les coefficients pour le lambda optimal\nprint(coef(cv_lasso, s = \"lambda.min\"))\n\n\n33 x 1 sparse Matrix of class \"dgCMatrix\"\n                             s1\n(Intercept)       -5.521795e-01\nKnitting           2.882558e+00\nCards_games        2.349254e-01\nGambling          -3.337312e-01\nCooking            1.162588e+00\nDIY               -1.086545e+00\nVegetable_garden  -3.464071e-01\nOrnamental_garden  3.256615e-01\nFishing_hunting   -1.450190e+00\nCollection        -5.394222e-01\nVehicle_custom    -1.510231e+00\nMaking_music      -1.484874e-01\nDiary              1.379585e+00\nWriting            .           \nPainting           4.704994e-01\nMontage           -9.872001e-01\nCircus             .           \nPottery            4.123501e-01\nTheater           -8.086209e-02\nDrawing           -2.584548e-02\nDancing            1.596506e+00\nPhotography       -4.617016e-01\nGenealogy         -2.927618e-01\nScience           -6.851022e-01\nNone              -9.890995e-02\nNo_Amateur         3.514798e-01\nVideo_games       -1.754886e-01\nTV                 4.929155e-01\nRadio             -1.240134e-01\nLibrary           -9.026366e-16\nMuseums           -1.205780e-01\nInternet           1.147213e-01\nConcert            8.777883e-02\n\n\ncode R\nprint(best_lambda)\n\n\n[1] 0.001109779\n\n\ncode R\n# Préparer X_test (même traitement que pour l'entraînement)\nx_test &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                       Vegetable_garden + Ornamental_garden + Fishing_hunting + \n                       Collection + Vehicle_custom + Making_music + Diary + Writing + \n                       Painting + Montage + Circus + Pottery + Theater + Drawing + \n                       Dancing + Photography + Genealogy + Science + None + No_Amateur +\n                       Video_games + TV + Radio + Library + Museums + Internet + Concert,\n                       test_data)[, -1]\n\n# Prédire les probabilités sur les données de test avec le meilleur lambda\npreds &lt;- predict(cv_lasso, newx = x_test, s = \"lambda.min\", type = \"response\")\n\n# Variable cible y_test pour l'ensemble de test\ny_test &lt;- test_data$SEXE\n\n# Calcul de l'AUC avec pROC\nroc_curve &lt;- roc(y_test, preds)\nauc_value &lt;- auc(roc_curve)\nprint(paste(\"AUC:\", auc_value))\n\n\n[1] \"AUC: 0.873070159752027\"\n\n\ncode R\n# Calculer la courbe ROC\nroc_curve &lt;- roc(y_test, preds)\n\n# Afficher la courbe ROC\nplot(roc_curve, main = \"Courbe ROC\", col = \"blue\", lwd = 2)\n\n# Optionnel : Ajouter la ligne de base (diagonale)\nabline(a = 0, b = 1, col = \"red\", lty = 2)\n\n\n\n\n\n\n\n\n\ncode R\n# Afficher les coefficients pour le meilleur lambda\ncoefficients &lt;- coef(cv_lasso, s = \"lambda.min\")\n\n# Convertir en data.frame pour une meilleure lisibilité\ncoefficients_df &lt;- as.data.frame(as.matrix(coefficients))\ncolnames(coefficients_df) &lt;- \"Coefficient\"\ncoefficients_df$Variable &lt;- rownames(coefficients_df)\n\n# Filtrer pour ne garder que les variables avec des coefficients non nuls\ncoefficients_non_zero &lt;- coefficients_df[coefficients_df$Coefficient != 0, ]\n\n# Afficher les variables gardées et leurs coefficients\nprint(coefficients_non_zero)\n\n\n                    Coefficient          Variable\n(Intercept)       -5.521795e-01       (Intercept)\nKnitting           2.882558e+00          Knitting\nCards_games        2.349254e-01       Cards_games\nGambling          -3.337312e-01          Gambling\nCooking            1.162588e+00           Cooking\nDIY               -1.086545e+00               DIY\nVegetable_garden  -3.464071e-01  Vegetable_garden\nOrnamental_garden  3.256615e-01 Ornamental_garden\nFishing_hunting   -1.450190e+00   Fishing_hunting\nCollection        -5.394222e-01        Collection\nVehicle_custom    -1.510231e+00    Vehicle_custom\nMaking_music      -1.484874e-01      Making_music\nDiary              1.379585e+00             Diary\nPainting           4.704994e-01          Painting\nMontage           -9.872001e-01           Montage\nPottery            4.123501e-01           Pottery\nTheater           -8.086209e-02           Theater\nDrawing           -2.584548e-02           Drawing\nDancing            1.596506e+00           Dancing\nPhotography       -4.617016e-01       Photography\nGenealogy         -2.927618e-01         Genealogy\nScience           -6.851022e-01           Science\nNone              -9.890995e-02              None\nNo_Amateur         3.514798e-01        No_Amateur\nVideo_games       -1.754886e-01       Video_games\nTV                 4.929155e-01                TV\nRadio             -1.240134e-01             Radio\nLibrary           -9.026366e-16           Library\nMuseums           -1.205780e-01           Museums\nInternet           1.147213e-01          Internet\nConcert            8.777883e-02           Concert\n\n\ncode R\n###CREATION INDICE\n\n# Récupérer les coefficients du modèle pour le meilleur lambda\ncoefficients &lt;- coef(cv_lasso, s = \"lambda.min\")\n\n# Convertir en data.frame et filtrer les variables non nulles\ncoefficients_df &lt;- as.data.frame(as.matrix(coefficients))\ncolnames(coefficients_df) &lt;- \"Coefficient\"\ncoefficients_df$Variable &lt;- rownames(coefficients_df)\ncoefficients_non_zero &lt;- coefficients_df[coefficients_df$Coefficient != 0, ]\n\n# Préparer la matrice X des pratiques pour l'ensemble de test (ou d'entraînement si nécessaire)\nx_test &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                       Vegetable_garden + Ornamental_garden + Fishing_hunting + \n                       Collection + Vehicle_custom + Making_music + Diary + Writing + \n                       Painting + Montage + Circus + Pottery + Theater + Drawing + \n                       Dancing + Photography + Genealogy + Science + None + No_Amateur +\n                       Video_games + TV + Radio + Library + Museums + Internet + Concert,\n                       test_data)[, -1]  # Assurez-vous d'enlever l'intercept avec [, -1]\n\n# Sélectionner les variables pertinentes\nmatched_vars &lt;- intersect(rownames(coefficients_non_zero), colnames(x_test))\nx_test &lt;- x_test[, matched_vars, drop = FALSE]\ncoef_vector &lt;- coefficients_non_zero$Coefficient[matched_vars]  # Associer les coefficients\n\nprint(paste(\"Dimension de x_test :\", dim(x_test)[1], \"x\", dim(x_test)[2]))\n\n\n[1] \"Dimension de x_test : 3078 x 30\"\n\n\ncode R\nprint(paste(\"Longueur de coef_vector :\", length(coef_vector)))\n\n\n[1] \"Longueur de coef_vector : 30\"\n\n\ncode R\nprint(paste(\"Nombre de valeurs NA dans x_test :\", sum(is.na(x_test))))\n\n\n[1] \"Nombre de valeurs NA dans x_test : 0\"\n\n\ncode R\nprint(paste(\"Nombre de valeurs NA dans coef_vector :\", sum(is.na(coef_vector))))\n\n\n[1] \"Nombre de valeurs NA dans coef_vector : 30\"\n\n\ncode R\nprint(\"Variables dans coefficients_non_zero :\")\n\n\n[1] \"Variables dans coefficients_non_zero :\"\n\n\ncode R\nprint(coefficients_non_zero$Variable)\n\n\n [1] \"(Intercept)\"       \"Knitting\"          \"Cards_games\"      \n [4] \"Gambling\"          \"Cooking\"           \"DIY\"              \n [7] \"Vegetable_garden\"  \"Ornamental_garden\" \"Fishing_hunting\"  \n[10] \"Collection\"        \"Vehicle_custom\"    \"Making_music\"     \n[13] \"Diary\"             \"Painting\"          \"Montage\"          \n[16] \"Pottery\"           \"Theater\"           \"Drawing\"          \n[19] \"Dancing\"           \"Photography\"       \"Genealogy\"        \n[22] \"Science\"           \"None\"              \"No_Amateur\"       \n[25] \"Video_games\"       \"TV\"                \"Radio\"            \n[28] \"Library\"           \"Museums\"           \"Internet\"         \n[31] \"Concert\"          \n\n\ncode R\nprint(\"Colonnes de x_test :\")\n\n\n[1] \"Colonnes de x_test :\"\n\n\ncode R\nprint(colnames(x_test))\n\n\n [1] \"Knitting\"          \"Cards_games\"       \"Gambling\"         \n [4] \"Cooking\"           \"DIY\"               \"Vegetable_garden\" \n [7] \"Ornamental_garden\" \"Fishing_hunting\"   \"Collection\"       \n[10] \"Vehicle_custom\"    \"Making_music\"      \"Diary\"            \n[13] \"Painting\"          \"Montage\"           \"Pottery\"          \n[16] \"Theater\"           \"Drawing\"           \"Dancing\"          \n[19] \"Photography\"       \"Genealogy\"         \"Science\"          \n[22] \"None\"              \"No_Amateur\"        \"Video_games\"      \n[25] \"TV\"                \"Radio\"             \"Library\"          \n[28] \"Museums\"           \"Internet\"          \"Concert\"          \n\n\ncode R\n# Exclure \"(Intercept)\" des coefficients\ncoefficients_filtered &lt;- coefficients_non_zero[coefficients_non_zero$Variable != \"(Intercept)\", ]\n\n# Aligner les coefficients sur x_test\ncoef_vector &lt;- coefficients_filtered$Coefficient[match(colnames(x_test), coefficients_filtered$Variable)]\n\n\n\n# Calcul des scores\ntest_data$score &lt;- x_test %*% coef_vector\n\n# Normalisation des scores\nmin_score &lt;- min(test_data$score, na.rm = TRUE)\nmax_score &lt;- max(test_data$score, na.rm = TRUE)\n\nif (max_score &gt; min_score) {\n  test_data$score_normalise &lt;- (test_data$score - min_score) / (max_score - min_score)\n} else {\n  test_data$score_normalise &lt;- 0\n}\n\n# Visualisation avec ggplot2\nlibrary(ggplot2)\nggplot(test_data, aes(x = score_normalise, color = SEXE, fill = SEXE)) +\n  geom_density(alpha = 0.4) + \n  labs(title = \"Densité du Score Normalisé\", x = \"Score Normalisé\", y = \"Densité\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal()\ncode R\n# Préparer la matrice X pour l'ensemble complet (train + test)\nx_full &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                       Vegetable_garden + Ornamental_garden + Fishing_hunting + \n                       Collection + Vehicle_custom + Making_music + Diary + Writing + \n                       Painting + Montage + Circus + Pottery + Theater + Drawing + \n                       Dancing + Photography + Genealogy + Science + None + No_Amateur +\n                       Video_games + TV + Radio + Library + Museums + Internet + Concert,\n                       my_data_frame)[, -1]  # Exclure l'intercept\n\n# Sélectionner les variables pertinentes (identiques à celles du modèle LASSO)\nmatched_vars &lt;- intersect(rownames(coefficients_non_zero), colnames(x_full))\nx_full &lt;- x_full[, matched_vars, drop = FALSE]  # Garder uniquement les variables sélectionnées\n# Aligner les coefficients sur x_full\ncoef_vector_full &lt;- coefficients_filtered$Coefficient[match(colnames(x_full), coefficients_filtered$Variable)]\n\n# Calcul des scores pour l'ensemble complet\nmy_data_frame$score &lt;- x_full %*% coef_vector_full\n# Normalisation des scores\nmin_score_full &lt;- min(my_data_frame$score, na.rm = TRUE)\nmax_score_full &lt;- max(my_data_frame$score, na.rm = TRUE)\n\nif (max_score_full &gt; min_score_full) {\n  my_data_frame$score_normalise &lt;- (my_data_frame$score - min_score_full) / (max_score_full - min_score_full)\n} else {\n  my_data_frame$score_normalise &lt;- 0\n}\n# Visualisation du score normalisé pour l'ensemble complet avec ggplot2\nlibrary(ggplot2)\nggplot(my_data_frame, aes(x = score_normalise, color = SEXE, fill = SEXE)) +\n  geom_density(alpha = 0.4) + \n  labs(title = \"Densité du Score Normalisé (Ensemble Complet)\", x = \"Score Normalisé\", y = \"Densité\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#comparaisons",
    "href": "construction_indice.html#comparaisons",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.2 Comparaisons",
    "text": "1.2 Comparaisons\n\n\ncode R\n# Calculer la corrélation entre indice_normalise et score_normalise\ncorrelation_value &lt;- cor(my_data_frame$identity, my_data_frame$score_normalise, use = \"complete.obs\")\nprint(paste(\"Corrélation entre indice_normalise et score_normalise :\", correlation_value))\n\n\n[1] \"Corrélation entre indice_normalise et score_normalise : -0.645386557366119\"\n\n\ncode R\n# Visualiser la relation entre indice_normalise et score_normalise\nlibrary(ggplot2)\nggplot(my_data_frame, aes(x = identity, y = score_normalise)) +\n  geom_point(alpha = 0.5) +\n  labs(title = \"Relation entre indice_normalise et score_normalise\", \n       x = \"Indice Normalisé\", \n       y = \"Score Normalisé\") +\n  theme_minimal() +\n  geom_smooth(method = \"lm\", col = \"red\", se = FALSE)  # Ajouter une droite de régression linéaire\n\n\n\n\n\n\n\n\n\n\n\ncode R\nn_2 &lt;- nrow(my_data_frame)\n\n# Indices pour la division (2/3 pour l'entraînement, 1/3 pour le test)\ntrain_index &lt;- sample(1:n_2, size = 2 * n_2 / 3)  # 2/3 des indices pour l'entraînement\n\n# Créer l'ensemble d'entraînement et l'ensemble de test\ntrain_data &lt;- my_data_frame[train_index, ]  # Enregistrement d'entraînement\ntest_data &lt;- my_data_frame[-train_index, ]  # Enregistrement de test\n\n# Vérifier les tailles\ncat(\"Nombre d'observations dans l'ensemble d'entraînement :\", nrow(train_data), \"\\n\")\n\n\nNombre d'observations dans l'ensemble d'entraînement : 6156 \n\n\ncode R\ncat(\"Nombre d'observations dans l'ensemble de test :\", nrow(test_data), \"\\n\")\n\n\nNombre d'observations dans l'ensemble de test : 3078 \n\n\ncode R\n# Charger les bibliothèques nécessaires\nlibrary(glmnet)\nlibrary(pROC)\n\n# Définir la matrice X pour l'entraînement\nx_2 &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                  Vegetable_garden + Fishing_hunting + \n                  Collection + Vehicle_custom + Making_music + Diary + Writing + \n                  Painting + Montage +  Pottery + Theater + Drawing + \n                  Dancing + Photography + Genealogy + Science + None + \n                  Video_games + Library +  Concert,\n                  train_data)[, -1]\n\n# Variable cible y pour l'entraînement\ny_2 &lt;- train_data$SEXE\n\n# Ajuster le modèle LASSO avec validation croisée\ncv_lasso_2 &lt;- cv.glmnet(x_2, y_2, alpha = 1, family = \"binomial\")\nbest_lambda_2 &lt;- cv_lasso_2$lambda.min  # Lambda optimal\n\n# Vérifie les coefficients pour le lambda optimal\nprint(coef(cv_lasso_2, s = \"lambda.min\"))\n\n\n26 x 1 sparse Matrix of class \"dgCMatrix\"\n                          s1\n(Intercept)       0.11260864\nKnitting          3.01800722\nCards_games       0.16677278\nGambling         -0.34566529\nCooking           1.12798392\nDIY              -1.01219567\nVegetable_garden -0.30731087\nFishing_hunting  -1.40787072\nCollection       -0.69110001\nVehicle_custom   -1.68777530\nMaking_music     -0.13299836\nDiary             1.46711705\nWriting          -0.16958639\nPainting          0.48089960\nMontage          -1.00019427\nPottery           0.52939803\nTheater          -0.06515215\nDrawing          -0.15971724\nDancing           1.52751004\nPhotography      -0.50794702\nGenealogy        -0.33199701\nScience          -0.87343121\nNone             -0.11072248\nVideo_games      -0.16572230\nLibrary          -0.01094454\nConcert           0.01127190\n\n\ncode R\nprint(best_lambda_2)\n\n\n[1] 0.0005315669\n\n\ncode R\n# Préparer X_test (même traitement que pour l'entraînement)\nx_test_2 &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                  Vegetable_garden + Fishing_hunting + \n                  Collection + Vehicle_custom + Making_music + Diary + Writing + \n                  Painting + Montage +  Pottery + Theater + Drawing + \n                  Dancing + Photography + Genealogy + Science + None + \n                  Video_games + Library +  Concert,\n                       test_data)[, -1]\n\n# Prédire les probabilités sur les données de test avec le meilleur lambda\npreds_2 &lt;- predict(cv_lasso_2, newx = x_test_2, s = \"lambda.min\", type = \"response\")\n\n# Variable cible y_test pour l'ensemble de test\ny_test_2 &lt;- test_data$SEXE\n\n# Calcul de l'AUC avec pROC\nroc_curve_2 &lt;- roc(y_test_2, preds_2)\nauc_value_2 &lt;- auc(roc_curve_2)\nprint(paste(\"AUC:\", auc_value_2))\n\n\n[1] \"AUC: 0.868197882559135\"\n\n\ncode R\n# Calculer la courbe ROC\nroc_curve_2 &lt;- roc(y_test_2, preds_2)\n\n# Afficher la courbe ROC\nplot(roc_curve_2, main = \"Courbe ROC 2\", col = \"blue\", lwd = 2)\n\n# Optionnel : Ajouter la ligne de base (diagonale)\nabline(a = 0, b = 1, col = \"red\", lty = 2)\n\n\n\n\n\n\n\n\n\ncode R\n# Afficher les coefficients pour le meilleur lambda\ncoefficients_2 &lt;- coef(cv_lasso_2, s = \"lambda.min\")\n\n# Convertir en data.frame pour une meilleure lisibilité\ncoefficients_df_2 &lt;- as.data.frame(as.matrix(coefficients_2))\ncolnames(coefficients_df_2) &lt;- \"Coefficient\"\ncoefficients_df_2$Variable &lt;- rownames(coefficients_df_2)\n\n# Filtrer pour ne garder que les variables avec des coefficients non nuls\ncoefficients_non_zero_2 &lt;- coefficients_df_2[coefficients_df_2$Coefficient != 0, ]\n\n# Afficher les variables gardées et leurs coefficients\nprint(coefficients_non_zero_2)\n\n\n                 Coefficient         Variable\n(Intercept)       0.11260864      (Intercept)\nKnitting          3.01800722         Knitting\nCards_games       0.16677278      Cards_games\nGambling         -0.34566529         Gambling\nCooking           1.12798392          Cooking\nDIY              -1.01219567              DIY\nVegetable_garden -0.30731087 Vegetable_garden\nFishing_hunting  -1.40787072  Fishing_hunting\nCollection       -0.69110001       Collection\nVehicle_custom   -1.68777530   Vehicle_custom\nMaking_music     -0.13299836     Making_music\nDiary             1.46711705            Diary\nWriting          -0.16958639          Writing\nPainting          0.48089960         Painting\nMontage          -1.00019427          Montage\nPottery           0.52939803          Pottery\nTheater          -0.06515215          Theater\nDrawing          -0.15971724          Drawing\nDancing           1.52751004          Dancing\nPhotography      -0.50794702      Photography\nGenealogy        -0.33199701        Genealogy\nScience          -0.87343121          Science\nNone             -0.11072248             None\nVideo_games      -0.16572230      Video_games\nLibrary          -0.01094454          Library\nConcert           0.01127190          Concert\n\n\ncode R\n###CREATION INDICE\n\n# Récupérer les coefficients du modèle pour le meilleur lambda\ncoefficients_2 &lt;- coef(cv_lasso_2, s = \"lambda.min\")\n\n# Convertir en data.frame et filtrer les variables non nulles\ncoefficients_df_2 &lt;- as.data.frame(as.matrix(coefficients_2))\ncolnames(coefficients_df_2) &lt;- \"Coefficient\"\ncoefficients_df_2$Variable &lt;- rownames(coefficients_df_2)\ncoefficients_non_zero_2 &lt;- coefficients_df_2[coefficients_df_2$Coefficient != 0, ]\n\n# Préparer la matrice X des pratiques pour l'ensemble de test (ou d'entraînement si nécessaire)\nx_test_2 &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                  Vegetable_garden + Fishing_hunting + \n                  Collection + Vehicle_custom + Making_music + Diary + Writing + \n                  Painting + Montage +  Pottery + Theater + Drawing + \n                  Dancing + Photography + Genealogy + Science + None + \n                  Video_games + Library +  Concert,\n                       test_data)[, -1]  # Assurez-vous d'enlever l'intercept avec [, -1]\n\n# Sélectionner les variables pertinentes\nmatched_vars_2 &lt;- intersect(rownames(coefficients_non_zero_2), colnames(x_test_2))\nx_test_2 &lt;- x_test_2[, matched_vars_2, drop = FALSE]\ncoef_vector_2 &lt;- coefficients_non_zero_2$Coefficient[matched_vars_2]  # Associer les coefficients\n\n#print(paste(\"Dimension de x_test :\", dim(x_test)[1], \"x\", dim(x_test)[2]))\n#print(paste(\"Longueur de coef_vector :\", length(coef_vector)))\n#print(paste(\"Nombre de valeurs NA dans x_test :\", sum(is.na(x_test))))\n#print(paste(\"Nombre de valeurs NA dans coef_vector :\", sum(is.na(coef_vector))))\n\n#print(\"Variables dans coefficients_non_zero :\")\n#print(coefficients_non_zero$Variable)\n\n#print(\"Colonnes de x_test :\")\n#print(colnames(x_test))\n\n\n# Exclure \"(Intercept)\" des coefficients\ncoefficients_filtered_2 &lt;- coefficients_non_zero_2[coefficients_non_zero_2$Variable != \"(Intercept)\", ]\n\n# Aligner les coefficients sur x_test\ncoef_vector_2 &lt;- coefficients_filtered_2$Coefficient[match(colnames(x_test_2), coefficients_filtered_2$Variable)]\n\n\n\n# Calcul des scores\ntest_data$score_2 &lt;- x_test_2 %*% coef_vector_2\n\n# Normalisation des scores\nmin_score_2 &lt;- min(test_data$score_2, na.rm = TRUE)\nmax_score_2 &lt;- max(test_data$score_2, na.rm = TRUE)\n\nif (max_score_2 &gt; min_score_2) {\n  test_data$score_normalise_2 &lt;- (test_data$score_2 - min_score_2) / (max_score_2 - min_score_2)\n} else {\n  test_data$score_normalise_2 &lt;- 0\n}\n\n# Visualisation avec ggplot2\nlibrary(ggplot2)\nggplot(test_data, aes(x = score_normalise_2, color = SEXE, fill = SEXE)) +\n  geom_density(alpha = 0.4) + \n  labs(title = \"Densité du Score Normalisé 2\", x = \"Score Normalisé 2\", y = \"Densité\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\ncode R\n# Préparer la matrice X pour l'ensemble complet (train + test)\nx_full_2 &lt;- model.matrix(SEXE ~ Knitting + Cards_games + Gambling + Cooking + DIY +\n                  Vegetable_garden + Fishing_hunting + \n                  Collection + Vehicle_custom + Making_music + Diary + Writing + \n                  Painting + Montage +  Pottery + Theater + Drawing + \n                  Dancing + Photography + Genealogy + Science + None + \n                  Video_games + Library +  Concert,\n                       my_data_frame)[, -1]  # Exclure l'intercept\n\n# Sélectionner les variables pertinentes (identiques à celles du modèle LASSO)\nmatched_vars_2 &lt;- intersect(rownames(coefficients_non_zero_2), colnames(x_full_2))\nx_full_2 &lt;- x_full_2[, matched_vars_2, drop = FALSE]  # Garder uniquement les variables sélectionnées\n# Aligner les coefficients sur x_full\ncoef_vector_full_2 &lt;- coefficients_filtered_2$Coefficient[match(colnames(x_full_2), coefficients_filtered_2$Variable)]\n\n# Calcul des scores pour l'ensemble complet\nmy_data_frame$score_2 &lt;- x_full_2 %*% coef_vector_full_2\n# Normalisation des scores\nmin_score_full_2 &lt;- min(my_data_frame$score_2, na.rm = TRUE)\nmax_score_full_2 &lt;- max(my_data_frame$score_2, na.rm = TRUE)\n\nif (max_score_full_2 &gt; min_score_full_2) {\n  my_data_frame$score_normalise_2 &lt;- (my_data_frame$score_2 - min_score_full_2) / (max_score_full_2 - min_score_full_2)\n} else {\n  my_data_frame$score_normalise_2 &lt;- 0\n}\n# Visualisation du score normalisé pour l'ensemble complet avec ggplot2\nlibrary(ggplot2)\nggplot(my_data_frame, aes(x = score_normalise_2, color = SEXE, fill = SEXE)) +\n  geom_density(alpha = 0.4) + \n  labs(title = \"Densité du Score Normalisé 2(Ensemble Complet)\", x = \"Score Normalisé\", y = \"Densité\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\ncode R\n# Calculer la corrélation entre indice_normalise et score_normalise\ncorrelation_value_2 &lt;- cor(my_data_frame$identity, my_data_frame$score_normalise_2, use = \"complete.obs\")\nprint(paste(\"Corrélation entre indice_normalise et score_normalise 2:\", correlation_value))\n\n\n[1] \"Corrélation entre indice_normalise et score_normalise 2: -0.645386557366119\"\n\n\ncode R\n# Visualiser la relation entre indice_normalise et score_normalise\nlibrary(ggplot2)\nggplot(my_data_frame, aes(x = identity, y = score_normalise_2)) +\n  geom_point(alpha = 0.5) +\n  labs(title = \"Relation entre indice_normalise et score_normalise 2\", \n       x = \"Indice Normalisé\", \n       y = \"Score Normalisé\") +\n  theme_minimal() +\n  geom_smooth(method = \"lm\", col = \"red\", se = FALSE)  # Ajouter une droite de régression linéaire\n\n\n\n\n\n\n\n\n\ncode R\n# Créer un data frame pour stocker les résultats\nresult_table_score_2 &lt;- data.frame(Activity_2 = character(0), Accuracy_2 = numeric(0))\n\ncultural_activities_2 &lt;- c(\n   \"Knitting\", \"Cards_games\", \"Gambling\", \"Cooking\", \"DIY\",\n   \"Vegetable_garden\", \"Fishing_hunting\", \"Collection\", \"Vehicle_custom\",\n   \"Making_music\", \"Diary\", \"Writing\", \"Painting\", \"Montage\",\n   \"Pottery\", \"Theater\", \"Drawing\", \"Dancing\", \"Photography\",\n   \"Genealogy\", \"Science\", \"None\", \"Video_games\", \"Library\", \"Concert\"\n)\n\nfor (activity_2 in cultural_activities_2) {\n  # Effectuer une régression Probit pour l'activité culturelle actuelle\n  model_formula_2 &lt;- as.formula(paste(activity_2, \"~ score_normalise_2\"))\n  model_2 &lt;- glm(model_formula_2, data = my_data_frame, family = binomial(link = \"probit\"))\n \n  # Calculer les prédictions\n  predicted_2 &lt;- ifelse(predict(model_2, type = \"response\") &gt;= 0.5, 1, 0)\n \n  # Calculer la précision\n  correct_predictions_2 &lt;- sum(predicted_2 == my_data_frame[[activity_2]])\n  total_predictions_2 &lt;- nrow(my_data_frame)\n  accuracy_2 &lt;- (correct_predictions_2 / total_predictions_2) * 100\n \n  # Ajouter le résultat au data frame\n  result_table_score_2 &lt;- rbind(result_table_score_2, data.frame(Activity_2 = activity_2, Accuracy_2 = accuracy_2))\n}\n\n# Afficher le tableau des résultats\nprint(result_table_score_2)\n\n\n         Activity_2 Accuracy_2\n1          Knitting   92.92831\n2       Cards_games   56.44358\n3          Gambling   78.77410\n4           Cooking   68.72428\n5               DIY   59.97401\n6  Vegetable_garden   72.07061\n7   Fishing_hunting   90.25341\n8        Collection   92.67923\n9    Vehicle_custom   96.58869\n10     Making_music   65.97358\n11            Diary   84.53541\n12          Writing   87.48105\n13         Painting   78.68746\n14          Montage   84.54624\n15          Pottery   89.50617\n16          Theater   86.10570\n17          Drawing   76.72731\n18          Dancing   76.80312\n19      Photography   74.53974\n20        Genealogy   88.21746\n21          Science   88.30409\n22             None   71.20425\n23      Video_games   61.47932\n24          Library   83.47412\n25          Concert   82.06628\n\n\n\n\ncode R\nmy_data_frame$score_scale &lt;- cut(\n  my_data_frame$score_normalise,\n  breaks = 7,  # Automatically divide into 7 slices\n  labels = c(\"Very Masculine\", \"1\", \"2\", \"3\", \"4\", \"5\", \"Very Feminine\"), \n  include.lowest = TRUE  \n)\ntable1 &lt;-\n  my_data_frame |&gt; \n  tbl_summary(include = c(score_scale),\n  by=Sex ,)|&gt; \n    add_p()\ntable1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nMen N = 4,1621\nWomen N = 5,0721\np-value2\n\n\n\n\nscore_scale\n\n\n\n\n&lt;0.001\n\n\n    Very Masculine\n18 (0.4%)\n0 (0%)\n\n\n\n\n    1\n405 (9.7%)\n15 (0.3%)\n\n\n\n\n    2\n1,871 (45%)\n412 (8.1%)\n\n\n\n\n    3\n1,659 (40%)\n2,075 (41%)\n\n\n\n\n    4\n189 (4.5%)\n1,646 (32%)\n\n\n\n\n    5\n19 (0.5%)\n792 (16%)\n\n\n\n\n    Very Feminine\n1 (&lt;0.1%)\n132 (2.6%)\n\n\n\n\n\n1 n (%)\n\n\n2 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\ncode R\n# Proportions de 'score_scale' par genre\ntable_score_gender &lt;- table(my_data_frame$score_scale, my_data_frame$Sex)\ntable_score_gender_percent &lt;- prop.table(table_score_gender, 2) * 100  # Calcul par genre\ntable_score_gender_percent\n\n\n                \n                         Men       Women\n  Very Masculine  0.43248438  0.00000000\n  1               9.73089861  0.29574132\n  2              44.95434887  8.12302839\n  3              39.86064392 40.91088328\n  4               4.54108602 32.45268139\n  5               0.45651129 15.61514196\n  Very Feminine   0.02402691  2.60252366\n\n\ncode R\n# Proportions de 'satisfaction' par genre\ntable_satisfaction_gender &lt;- table(my_data_frame$satisfaction, my_data_frame$Sex)\ntable_satisfaction_gender_percent &lt;- prop.table(table_satisfaction_gender, 2) * 100  # Calcul par genre\ntable_satisfaction_gender_percent\n\n\n        \n              Men    Women\n  High   35.15399 32.66917\n  Low    35.80366 39.75143\n  Medium 29.04235 27.57940\n\n\n\n\ncode R\n# Charger les bibliothèques nécessaires\nlibrary(ggplot2)\nlibrary(plotly)\nlibrary(scales)\n\n# Création du graphique avec ggplot\np &lt;- ggplot(as.data.frame(table_score_gender_percent), \n            aes(x = Var1, y = Freq, fill = Var2, text = paste0(\"Proportion: \", percent(Freq / 100)))) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  labs(title = \"Répartition des scores par genre\",\n       x = \"Score (1-7)\", y = \"Proportion (%)\") +\n  scale_y_continuous(labels = percent_format(scale = 1)) +\n  theme_minimal() +\n  theme(legend.title = element_blank())\n\n# Convertir en graphique interactif avec ggplotly\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\n\n\ncode R\ntable1 &lt;-\n  my_data_frame |&gt; \n  tbl_summary(include = c(identity_scale),\n  by=Sex ,)|&gt; \n    add_p()\ntable1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nMen N = 4,1621\nWomen N = 5,0721\np-value2\n\n\n\n\nidentity_scale\n\n\n\n\n&lt;0.001\n\n\n    Very Feminine\n9 (0.2%)\n218 (4.3%)\n\n\n\n\n    1\n403 (9.7%)\n1,506 (30%)\n\n\n\n\n    2\n2,139 (51%)\n2,669 (53%)\n\n\n\n\n    3\n985 (24%)\n576 (11%)\n\n\n\n\n    4\n509 (12%)\n90 (1.8%)\n\n\n\n\n    5\n96 (2.3%)\n10 (0.2%)\n\n\n\n\n    Very Masculine\n21 (0.5%)\n3 (&lt;0.1%)\n\n\n\n\n\n1 n (%)\n\n\n2 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\ncode R\n# Proportions de 'score_scale' par genre\ntable_identity_gender &lt;- table(my_data_frame$identity_scale, my_data_frame$Sex)\ntable_identity_gender_percent &lt;- prop.table(table_identity_gender, 2) * 100  # Calcul par genre\ntable_identity_gender_percent\n\n\n                \n                         Men       Women\n  Very Feminine   0.21624219  4.29810726\n  1               9.68284479 29.69242902\n  2              51.39356079 52.62223975\n  3              23.66650649 11.35646688\n  4              12.22969726  1.77444795\n  5               2.30658337  0.19716088\n  Very Masculine  0.50456511  0.05914826\n\n\ncode R\n# Création du graphique avec ggplot\np &lt;- ggplot(as.data.frame(table_identity_gender_percent), \n            aes(x = Var1, y = Freq, fill = Var2, text = paste0(\"Proportion: \", percent(Freq / 100)))) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  labs(title = \"Répartition de l'identity scale par genre\",\n       x = \"Score (1-7)\", y = \"Proportion (%)\") +\n  scale_y_continuous(labels = percent_format(scale = 1)) +\n  theme_minimal() +\n  theme(legend.title = element_blank())\n\n# Convertir en graphique interactif avec ggplotly\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\n\n\ncode R\ntable1 &lt;-\n  my_data_frame |&gt; \n  tbl_summary(include = c(CLASSIF),\n  by=score_scale ,)|&gt; \n    add_p()\ntable1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nVery Masculine N = 181\n1 N = 4201\n2 N = 2,2831\n3 N = 3,7341\n4 N = 1,8351\n5 N = 8111\nVery Feminine N = 1331\np-value\n\n\n\n\nCLASSIF\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    1\n0 (0%)\n14 (8.2%)\n72 (9.1%)\n70 (6.4%)\n23 (4.3%)\n6 (3.2%)\n1 (3.1%)\n\n\n\n\n    2\n3 (38%)\n63 (37%)\n236 (30%)\n221 (20%)\n59 (11%)\n14 (7.5%)\n1 (3.1%)\n\n\n\n\n    3\n0 (0%)\n24 (14%)\n105 (13%)\n99 (9.1%)\n39 (7.4%)\n13 (7.0%)\n2 (6.3%)\n\n\n\n\n    4\n3 (38%)\n22 (13%)\n83 (10%)\n97 (8.9%)\n56 (11%)\n17 (9.1%)\n5 (16%)\n\n\n\n\n    5\n0 (0%)\n26 (15%)\n140 (18%)\n191 (18%)\n103 (19%)\n44 (24%)\n10 (31%)\n\n\n\n\n    6\n1 (13%)\n20 (12%)\n151 (19%)\n380 (35%)\n245 (46%)\n87 (47%)\n13 (41%)\n\n\n\n\n    7\n0 (0%)\n0 (0%)\n4 (0.5%)\n12 (1.1%)\n2 (0.4%)\n2 (1.1%)\n0 (0%)\n\n\n\n\n    8\n1 (13%)\n1 (0.6%)\n4 (0.5%)\n16 (1.5%)\n3 (0.6%)\n4 (2.1%)\n0 (0%)\n\n\n\n\n    9\n0 (0%)\n0 (0%)\n0 (0%)\n2 (0.2%)\n0 (0%)\n0 (0%)\n0 (0%)\n\n\n\n\n    Unknown\n10\n250\n1,488\n2,646\n1,305\n624\n101\n\n\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\ncode R\n# Proportions de 'score_scale' par profession\ntable_identity_gender &lt;- table(my_data_frame$CLASSIF, my_data_frame$score_scale)\ntable_identity_gender_percent &lt;- prop.table(table_identity_gender, 2) * 100  # Calcul par genre\ntable_identity_gender_percent\n\n\n   \n    Very Masculine          1          2          3          4          5\n  1      0.0000000  8.2352941  9.0566038  6.4338235  4.3396226  3.2085561\n  2     37.5000000 37.0588235 29.6855346 20.3125000 11.1320755  7.4866310\n  3      0.0000000 14.1176471 13.2075472  9.0992647  7.3584906  6.9518717\n  4     37.5000000 12.9411765 10.4402516  8.9154412 10.5660377  9.0909091\n  5      0.0000000 15.2941176 17.6100629 17.5551471 19.4339623 23.5294118\n  6     12.5000000 11.7647059 18.9937107 34.9264706 46.2264151 46.5240642\n  7      0.0000000  0.0000000  0.5031447  1.1029412  0.3773585  1.0695187\n  8     12.5000000  0.5882353  0.5031447  1.4705882  0.5660377  2.1390374\n  9      0.0000000  0.0000000  0.0000000  0.1838235  0.0000000  0.0000000\n   \n    Very Feminine\n  1     3.1250000\n  2     3.1250000\n  3     6.2500000\n  4    15.6250000\n  5    31.2500000\n  6    40.6250000\n  7     0.0000000\n  8     0.0000000\n  9     0.0000000\n\n\ncode R\n# Création du graphique avec ggplot\np &lt;- ggplot(as.data.frame(table_identity_gender_percent), \n            aes(x = Var1, y = Freq, fill = Var2, text = paste0(\"Proportion: \", percent(Freq / 100)))) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n \n  labs(title = \"Répartition des professions par score scale\",\n       x = \"Profession\", y = \"Proportion (%)\") +\n  scale_y_continuous(labels = percent_format(scale = 1)) +\n  theme_minimal() +\n  theme(legend.title = element_blank())\n\n# Convertir en graphique interactif avec ggplotly\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\n\n\ncode R\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(plotly)\n\n# Créer un tableau de fréquence pour la heatmap\nheatmap_data &lt;- my_data_frame %&gt;%\n  count(score_scale, satisfaction)  # Compte les occurrences\n\n# Ajouter une colonne pour l'affichage interactif\nheatmap_data &lt;- heatmap_data %&gt;%\n  mutate(info_text = paste0(\"Score: \", score_scale, \n                            \"\\nSatisfaction: \", satisfaction, \n                            \"\\nNombre d'observations: \", n))\n\n# Créer la heatmap avec ggplot\np &lt;- ggplot(heatmap_data, aes(x = as.factor(score_scale), \n                              y = as.factor(satisfaction), \n                              fill = n, text = info_text)) +\n  geom_tile() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  labs(title = \"Heatmap de la relation entre satisfaction et score\",\n       x = \"Score Scale\", y = \"Satisfaction\", fill = \"Fréquence\") +\n  theme_minimal()\n\n# Rendre le graphique interactif avec des infobulles personnalisées\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\n\n\ncode R\n# Créer un tableau de fréquence pour la heatmap\nheatmap_data &lt;- my_data_frame %&gt;%\n  count(identity_scale, satisfaction)  # Compte les occurrences\n\n# Ajouter une colonne pour l'affichage interactif\nheatmap_data &lt;- heatmap_data %&gt;%\n  mutate(info_text = paste0(\"Identity: \", identity_scale, \n                            \"\\nSatisfaction: \", satisfaction, \n                            \"\\nNombre d'observations: \", n))\n\n# Créer la heatmap avec ggplot\np &lt;- ggplot(heatmap_data, aes(x = as.factor(identity_scale), \n                              y = as.factor(satisfaction), \n                              fill = n, text = info_text)) +\n  geom_tile() +\n  scale_fill_gradient(low = \"white\", high = \"blue\") +\n  labs(title = \"Heatmap de la relation entre satisfaction et identity scale\",\n       x = \"Score Scale\", y = \"Satisfaction\", fill = \"Fréquence\") +\n  theme_minimal()\n\n# Rendre le graphique interactif avec des infobulles personnalisées\nggplotly(p, tooltip = \"text\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#ecarts-aux-normes-et-satisfaction",
    "href": "construction_indice.html#ecarts-aux-normes-et-satisfaction",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.3 Ecarts aux normes et satisfaction",
    "text": "1.3 Ecarts aux normes et satisfaction\n\n\ncode R\nmean_gender &lt;- tapply(my_data_frame$identity, my_data_frame$Sex, mean)\nsd_gender &lt;- tapply(my_data_frame$identity, my_data_frame$Sex, sd)\n\nmy_data_frame$distance_abs&lt;- abs((my_data_frame$identity - mean_gender[my_data_frame$Sex]) / sd_gender[my_data_frame$Sex])\n\nggplot(my_data_frame, aes(x = distance_abs, color = Sex, fill = Sex)) +\n  geom_density(alpha = 0.4) +\n  labs(title = \"Density of Distance to the Norm, by Sex\", \n       x = \"Distance to the Norm (Z-score)\", y = \"Density\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# Charger dplyr\nlibrary(dplyr)\n\n# Assurer que Sex est un facteur avec les niveaux appropriés\nmy_data_frame$Sex &lt;- factor(my_data_frame$Sex, levels = c(\"Men\", \"Women\"))\n\n# Calculer les moyennes et écarts-types par sexe avec dplyr\nmean_sd_by_sex &lt;- my_data_frame %&gt;%\n  group_by(Sex) %&gt;%\n  summarise(\n    mean_gender = mean(score_normalise, na.rm = TRUE),\n    sd_gender = sd(score_normalise, na.rm = TRUE)\n  )\n\n# Joindre les moyennes et écarts-types au dataframe original\nmy_data_frame &lt;- my_data_frame %&gt;%\n  left_join(mean_sd_by_sex, by = \"Sex\")\n\n# Calculer la distance absolue à la moyenne (Z-score)\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(distance_abs_2 = abs((score_normalise - mean_gender) / sd_gender))\n\n# Visualisation\nggplot(my_data_frame, aes(x = distance_abs_2, color = Sex, fill = Sex)) +\n  geom_density(alpha = 0.4) +\n  labs(title = \"Density of Distance to the Norm (Score), by Sex\", \n       x = \"Distance to the Norm (Z-score)\", y = \"Density\") +\n  scale_fill_manual(values = c(\"blue\", \"pink\")) +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal() +\n  geom_vline(data = my_data_frame, aes(xintercept = mean(distance_abs_2[Sex == \"Men\"]), color = \"Men\"), linetype = \"dashed\") +\n  geom_vline(data = my_data_frame, aes(xintercept = mean(distance_abs_2[Sex == \"Women\"]), color = \"Women\"), linetype = \"dashed\") +\n  theme(legend.title = element_blank())  # Enlever le titre de la légende\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# Charger le package MASS pour polr\nlibrary(MASS)\n\n# Modèle de régression ordinale (polr)\nmodel &lt;- polr(as.factor(satisfaction) ~ distance_abs_2, data = my_data_frame, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ distance_abs_2, data = my_data_frame, \n    method = \"logistic\")\n\nCoefficients:\n                 Value Std. Error t value\ndistance_abs_2 0.02273    0.03199  0.7105\n\nIntercepts:\n           Value    Std. Error t value \nHigh|Low    -0.6543   0.0340   -19.2524\nLow|Medium   0.9511   0.0348    27.3139\n\nResidual Deviance: 20135.53 \nAIC: 20141.53 \n(9 observations effacées parce que manquantes)\n\n\ncode R\n# Modèle de régression ordinale avec interaction entre sexe et distance aux normes\nmodel_interaction &lt;- polr(as.factor(satisfaction) ~ Sex * distance_abs_2, data = my_data_frame, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_interaction)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ Sex * distance_abs_2, \n    data = my_data_frame, method = \"logistic\")\n\nCoefficients:\n                           Value Std. Error t value\nSexWomen                 0.11297    0.06463   1.748\ndistance_abs_2           0.07744    0.04621   1.676\nSexWomen:distance_abs_2 -0.10629    0.06407  -1.659\n\nIntercepts:\n           Value    Std. Error t value \nHigh|Low    -0.5961   0.0477   -12.4889\nLow|Medium   1.0098   0.0486    20.7948\n\nResidual Deviance: 20132.29 \nAIC: 20142.29 \n(9 observations effacées parce que manquantes)\n\n\n\n\ncode R\n# Charger la bibliothèque Plotly\nlibrary(plotly)\n\n# Regroupement de distance_abs_2 en catégories (bins)\nmy_data_frame$distance_abs_2_bins &lt;- cut(my_data_frame$distance_abs_2, \n                                          breaks = 10,  # Divise en 10 intervalles\n                                          labels = FALSE, include.lowest = TRUE)\n\n# Comptage des occurrences pour chaque combinaison de Sexe, Satisfaction et Distance\nlibrary(dplyr)\ncount_data &lt;- my_data_frame %&gt;%\n  count(Sex, satisfaction, distance_abs_2_bins)\n\n# Création de la heatmap interactive avec Plotly\nfig &lt;- plot_ly(count_data, \n               x = ~distance_abs_2_bins, \n               y = ~as.factor(satisfaction), \n               z = ~n, \n               type = \"heatmap\", \n               colors = colorRamp(c(\"white\", \"blue\")), \n               colorbar = list(title = \"Nombre d'individus\"))\n\n# Ajouter des titres\nfig &lt;- fig %&gt;%\n  layout(title = \"Heatmap de Satisfaction par Sexe et Distance aux Normes\",\n         xaxis = list(title = \"Distance aux Normes (Binned)\"),\n         yaxis = list(title = \"Satisfaction\"))\n\n# Afficher la heatmap interactive\nfig\n\n\n\n\n\n\n\n\ncode R\nggplot(my_data_frame, aes(x = distance_abs_2, y = as.factor(satisfaction), color = Sex)) +\n  geom_point(alpha = 0.7) +\n  labs(title = \"Interaction entre Sexe et Distance aux Normes sur Satisfaction\",\n       x = \"Distance aux Normes (Z-score)\", y = \"Satisfaction\") +\n  scale_color_manual(values = c(\"blue\", \"pink\")) +\n  theme_minimal() +\n  facet_wrap(~Sex)\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# 1. Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\n\n# 2. Vérifier les valeurs manquantes dans le dataframe\n#summary(my_data_frame)\n\n# 3. Supprimer les lignes contenant des valeurs manquantes dans les colonnes pertinentes\nmy_data_frame_clean &lt;- my_data_frame[complete.cases(my_data_frame[c(\"satisfaction\", \"Sex\", \"distance_abs_2\")]), ]\n\n# Vérification de la taille du dataframe nettoyé\nnrow(my_data_frame_clean)  # Assure-toi que la taille est correcte\n\n\n[1] 9225\n\n\ncode R\n# 4. Convertir les variables catégoriques en facteurs avec les niveaux appropriés\nmy_data_frame_clean$satisfaction &lt;- factor(my_data_frame_clean$satisfaction, levels = c(\"Low\", \"Medium\", \"High\"))\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\n# 5. Ajuster le modèle de régression logistique ordinale\nmodel_clean &lt;- polr(as.factor(satisfaction) ~ distance_abs_2, data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ distance_abs_2, data = my_data_frame_clean, \n    method = \"logistic\")\n\nCoefficients:\n                  Value Std. Error t value\ndistance_abs_2 -0.09192    0.03231  -2.845\n\nIntercepts:\n            Value    Std. Error t value \nLow|Medium   -0.5649   0.0338   -16.7203\nMedium|High   0.5994   0.0339    17.7059\n\nResidual Deviance: 20127.93 \nAIC: 20133.93 \n\n\ncode R\n# 6. Calculer les probabilités pour chaque niveau de satisfaction\npred_prob_clean &lt;- predict(model_clean, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_high &lt;- pred_prob_clean[, \"High\"]\nmy_data_frame_clean$prob_medium &lt;- pred_prob_clean[, \"Medium\"]\nmy_data_frame_clean$prob_low &lt;- pred_prob_clean[, \"Low\"]\n\n# 7. Visualiser les résultats\nggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_high, color = \"High\"), size = 1) +\n  geom_line(aes(y = prob_medium, color = \"Medium\"), size = 1) +\n  geom_line(aes(y = prob_low, color = \"Low\"), size = 1) +\n  labs(title = \"Probabilité d'être satisfait selon l'écart aux normes\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"High\" = \"blue\", \"Medium\" = \"orange\", \"Low\" = \"red\")) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# 1. Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\n\n# 2. Vérifier les valeurs manquantes dans le dataframe\n#summary(my_data_frame)\n\n# 3. Supprimer les lignes contenant des valeurs manquantes dans les colonnes pertinentes\nmy_data_frame_clean &lt;- my_data_frame[complete.cases(my_data_frame[c(\"satisfaction\", \"Sex\", \"distance_abs_2\")]), ]\n\n# Vérification de la taille du dataframe nettoyé\nnrow(my_data_frame_clean)  # Assure-toi que la taille est correcte\n\n\n[1] 9225\n\n\ncode R\n# 4. Convertir les variables catégoriques en facteurs avec les niveaux appropriés\nmy_data_frame_clean$satisfaction &lt;- factor(my_data_frame_clean$satisfaction, levels = c(\"Low\", \"Medium\", \"High\"))\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\n# 5. Ajuster le modèle de régression logistique ordinale avec interaction entre Sex et distance_abs_2\nmodel_clean_sex &lt;- polr(as.factor(satisfaction) ~ distance_abs_2 * Sex, data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean_sex)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ distance_abs_2 * Sex, \n    data = my_data_frame_clean, method = \"logistic\")\n\nCoefficients:\n                           Value Std. Error t value\ndistance_abs_2          -0.11679    0.04617 -2.5298\nSexWomen                -0.18175    0.06454 -2.8160\ndistance_abs_2:SexWomen  0.05407    0.06464  0.8365\n\nIntercepts:\n            Value    Std. Error t value \nLow|Medium   -0.6607   0.0474   -13.9416\nMedium|High   0.5049   0.0472    10.7040\n\nResidual Deviance: 20114.33 \nAIC: 20124.33 \n\n\ncode R\n# 6. Calculer les probabilités pour chaque niveau de satisfaction par sexe\npred_prob_clean_sex &lt;- predict(model_clean_sex, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_high &lt;- pred_prob_clean_sex[, \"High\"]\nmy_data_frame_clean$prob_medium &lt;- pred_prob_clean_sex[, \"Medium\"]\nmy_data_frame_clean$prob_low &lt;- pred_prob_clean_sex[, \"Low\"]\n\n# 7. Visualiser les résultats en fonction de l'écart aux normes et du sexe (avec facet)\nggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_high, color = \"High\"), size = 1) +\n  geom_line(aes(y = prob_medium, color = \"Medium\"), size = 1) +\n  geom_line(aes(y = prob_low, color = \"Low\"), size = 1) +\n  labs(title = \"Probabilité d'être satisfait selon l'écart aux normes et par sexe\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"High\" = \"blue\", \"Medium\" = \"orange\", \"Low\" = \"red\")) +\n  theme_minimal() +\n  facet_wrap(~ Sex) +  # Facette par Sexe\n  theme(legend.title = element_blank())  # Enlever le titre de la légende\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# 1. Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# 2. Vérifier les valeurs manquantes dans le dataframe\n#summary(my_data_frame)\n\n# 3. Supprimer les lignes contenant des valeurs manquantes dans les colonnes pertinentes\nmy_data_frame_clean &lt;- my_data_frame[complete.cases(my_data_frame[c(\"satisfaction\", \"Sex\", \"distance_abs_2\")]), ]\n\n# Vérification de la taille du dataframe nettoyé\nnrow(my_data_frame_clean)  # Assure-toi que la taille est correcte\n\n\n[1] 9225\n\n\ncode R\n# 4. Convertir les variables catégoriques en facteurs avec les niveaux appropriés\nmy_data_frame_clean$satisfaction &lt;- factor(my_data_frame_clean$satisfaction, levels = c(\"Low\", \"Medium\", \"High\"))\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\n# 5. Ajuster le modèle de régression logistique ordinale avec interaction entre Sex et distance_abs_2\nmodel_clean_sex &lt;- polr(as.factor(satisfaction) ~ distance_abs_2 * Sex, data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean_sex)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ distance_abs_2 * Sex, \n    data = my_data_frame_clean, method = \"logistic\")\n\nCoefficients:\n                           Value Std. Error t value\ndistance_abs_2          -0.11679    0.04617 -2.5298\nSexWomen                -0.18175    0.06454 -2.8160\ndistance_abs_2:SexWomen  0.05407    0.06464  0.8365\n\nIntercepts:\n            Value    Std. Error t value \nLow|Medium   -0.6607   0.0474   -13.9416\nMedium|High   0.5049   0.0472    10.7040\n\nResidual Deviance: 20114.33 \nAIC: 20124.33 \n\n\ncode R\n# 6. Calculer les probabilités pour chaque niveau de satisfaction par sexe\npred_prob_clean_sex &lt;- predict(model_clean_sex, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_high &lt;- pred_prob_clean_sex[, \"High\"]\nmy_data_frame_clean$prob_medium &lt;- pred_prob_clean_sex[, \"Medium\"]\nmy_data_frame_clean$prob_low &lt;- pred_prob_clean_sex[, \"Low\"]\n\n# 7. Visualisation avec ggplot et ajout de commentaires pour les courbes\np &lt;- ggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_high, color = \"High\"), size = 1) +\n  geom_line(aes(y = prob_medium, color = \"Medium\"), size = 1) +\n  geom_line(aes(y = prob_low, color = \"Low\"), size = 1) +\n  labs(title = \"Probabilité d'être satisfait selon l'écart aux normes et par sexe\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"High\" = \"blue\", \"Medium\" = \"orange\", \"Low\" = \"red\")) +\n  theme_minimal() +\n  facet_wrap(~ Sex) +  # Facette par Sexe\n  theme(legend.title = element_blank())  # Enlever le titre de la légende\n\n# 8. Rendre le graphique interactif avec plotly et ajouter des annotations\np_interactive &lt;- ggplotly(p)\n\n# Ajouter des annotations pour chaque courbe\np_interactive &lt;- p_interactive %&gt;%\n  layout(\n    annotations = list(\n      list(\n        x = 0.5, y = 0.8, \n        text = \"Probabilité High\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      ),\n      list(\n        x = 0.5, y = 0.6, \n        text = \"Probabilité Medium\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      ),\n      list(\n        x = 0.5, y = 0.4, \n        text = \"Probabilité Low\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      )\n    )\n  )\n\n# Afficher le graphique interactif\np_interactive\n\n\n\n\n\n\n\n\ncode R\n# 1. Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# 2. Convertir la colonne de réponses A15 en une variable Santé catégorique (3 niveaux)\n# Supposons que ta variable santé est dans la colonne 'A15' de 'my_data_frame'\n\n# Remplacer les valeurs de A15 par les niveaux correspondants pour Santé\nmy_data_frame$Santé &lt;- factor(my_data_frame$A15,\n                              levels = c(1, 2, 3, 4, 5),\n                              labels = c(\"Very Good\", \"Good\", \"Fair\", \"Poor\", \"Very Poor\"))\n\n# Convertir en 3 niveaux: \"Good\", \"Fair\", \"Poor\"\nmy_data_frame$Santé &lt;- factor(my_data_frame$Santé,\n                              levels = c(\"Very Good\", \"Good\", \"Fair\", \"Poor\", \"Very Poor\"),\n                              labels = c(\"Good\", \"Good\", \"Fair\", \"Poor\", \"Poor\"))\n\n# Exclure les réponses \"Ne sait pas\" (6) et \"Refus\" (7)\nmy_data_frame_clean &lt;- my_data_frame[!(my_data_frame$A15 %in% c(6, 7)), ]\n\n# 3. Vérifier que la variable Santé est correctement créée\ntable(my_data_frame_clean$Santé)\n\n\n\nGood Fair Poor \n6410 1998  783 \n\n\ncode R\n# 4. Convertir 'Sex' en facteur\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\n# 5. Ajuster le modèle de régression logistique ordinale avec interaction entre Sex et distance_abs_2\nmodel_clean_sex_health &lt;- polr(Santé ~ distance_abs_2 * Sex, data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean_sex_health)\n\n\nCall:\npolr(formula = Santé ~ distance_abs_2 * Sex, data = my_data_frame_clean, \n    method = \"logistic\")\n\nCoefficients:\n                           Value Std. Error t value\ndistance_abs_2          -0.19064    0.05772 -3.3026\nSexWomen                 0.02624    0.07578  0.3463\ndistance_abs_2:SexWomen  0.21223    0.07738  2.7426\n\nIntercepts:\n          Value   Std. Error t value\nGood|Fair  0.7948  0.0554    14.3528\nFair|Poor  2.3365  0.0628    37.2049\n\nResidual Deviance: 14545.71 \nAIC: 14555.71 \n\n\ncode R\n# 6. Calculer les probabilités pour chaque niveau de Santé par sexe\npred_prob_clean_sex_health &lt;- predict(model_clean_sex_health, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_poor &lt;- pred_prob_clean_sex_health[, \"Poor\"]\nmy_data_frame_clean$prob_fair &lt;- pred_prob_clean_sex_health[, \"Fair\"]\nmy_data_frame_clean$prob_good &lt;- pred_prob_clean_sex_health[, \"Good\"]\n\n# 7. Visualisation avec ggplot et ajout de commentaires pour les courbes\np_health &lt;- ggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_poor, color = \"Poor\"), size = 1) +\n  geom_line(aes(y = prob_fair, color = \"Fair\"), size = 1) +\n  geom_line(aes(y = prob_good, color = \"Good\"), size = 1) +\n  labs(title = \"Probabilité d'être en bonne santé selon l'écart aux normes et par sexe\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"Poor\" = \"red\", \n                                \"Fair\" = \"orange\", \n                                \"Good\" = \"green\")) +\n  theme_minimal() +\n  facet_wrap(~ Sex) +  # Facette par Sexe\n  theme(legend.title = element_blank())  # Enlever le titre de la légende\n\n# 8. Rendre le graphique interactif avec plotly et ajouter des annotations\np_interactive_health &lt;- ggplotly(p_health)\n\n# Ajouter des annotations pour chaque courbe\np_interactive_health &lt;- p_interactive_health %&gt;%\n  layout(\n    annotations = list(\n      list(\n        x = 0.5, y = 0.8, \n        text = \"Probabilité Poor\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      ),\n      list(\n        x = 0.5, y = 0.6, \n        text = \"Probabilité Fair\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      ),\n      list(\n        x = 0.5, y = 0.4, \n        text = \"Probabilité Good\", \n        showarrow = TRUE, \n        arrowhead = 2,\n        ax = -50, ay = -50\n      )\n    )\n  )\n\n# Afficher le graphique interactif\np_interactive_health\n\n\n\n\n\n\n\n\ncode R\n# Créer la variable revenu en fonction de CRITREVENU\nmy_data_frame$revenu &lt;- NA  # Initialisation de la variable\n\n# Assignation des tranches de revenu\nmy_data_frame$revenu[my_data_frame$CRITREVENU %in% c(1, 2)] &lt;- \"Moins de 1000 euros\"\nmy_data_frame$revenu[my_data_frame$CRITREVENU %in% c(3, 4)] &lt;- \"1000 à 1499 euros\"\nmy_data_frame$revenu[my_data_frame$CRITREVENU %in% c(5, 6)] &lt;- \"1500 à 2499 euros\"\nmy_data_frame$revenu[my_data_frame$CRITREVENU %in% c(7, 8, 9, 10)] &lt;- \"2500 euros et plus\"\n\n# Convertir la variable revenu en facteur\nmy_data_frame$revenu &lt;- factor(my_data_frame$revenu, \n                               levels = c(\"Moins de 1000 euros\", \"1000 à 1499 euros\", \"1500 à 2499 euros\", \"2500 euros et plus\"))\n\n# Vérifier les niveaux de la nouvelle variable revenu\nsummary(my_data_frame$revenu)\n\n\nMoins de 1000 euros   1000 à 1499 euros   1500 à 2499 euros  2500 euros et plus \n                766                1280                2241                3775 \n               NA's \n               1172 \n\n\n\n\ncode R\n# Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# 2. Vérifier les valeurs manquantes dans le dataframe\n#summary(my_data_frame)\n\n# 3. Supprimer les lignes contenant des valeurs manquantes dans les colonnes pertinentes\nmy_data_frame_clean &lt;- my_data_frame[complete.cases(my_data_frame[c(\"satisfaction\", \"Sex\", \"distance_abs_2\", \"revenu\")]), ]\n\n# Vérification de la taille du dataframe nettoyé\nnrow(my_data_frame_clean)  # Assure-toi que la taille est correcte\n\n\n[1] 8057\n\n\ncode R\n# 4. Convertir les variables catégoriques en facteurs avec les niveaux appropriés\nmy_data_frame_clean$satisfaction &lt;- factor(my_data_frame_clean$satisfaction, levels = c(\"Low\", \"Medium\", \"High\"))\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\n\nmy_data_frame_clean$revenu &lt;- factor(my_data_frame_clean$revenu, \n                                     levels = c(\"Moins de 1000 euros\", \"1000 à 1499 euros\", \n                                                \"1500 à 2499 euros\", \"2500 euros et plus\"),\n                                     labels = c(\"&lt;1000\", \"[1000-1499]\", \"[1500-2499]\", \"≥2500\"))\n\n# 5. Ajuster le modèle de régression logistique ordinale avec interaction entre Sexe, revenu et distance_abs_2\nmodel_clean_sex_revenu &lt;- polr(as.factor(satisfaction) ~ distance_abs_2 * Sex * revenu, \n                               data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean_sex_revenu)\n\n\nCall:\npolr(formula = as.factor(satisfaction) ~ distance_abs_2 * Sex * \n    revenu, data = my_data_frame_clean, method = \"logistic\")\n\nCoefficients:\n                                             Value Std. Error t value\ndistance_abs_2                            -0.15950     0.1647 -0.9683\nSexWomen                                  -0.32601     0.2353 -1.3856\nrevenu[1000-1499]                         -0.06179     0.2271 -0.2721\nrevenu[1500-2499]                         -0.42024     0.1997 -2.1042\nrevenu≥2500                               -1.08504     0.1889 -5.7434\ndistance_abs_2:SexWomen                    0.22862     0.2295  0.9961\ndistance_abs_2:revenu[1000-1499]          -0.02571     0.2198 -0.1170\ndistance_abs_2:revenu[1500-2499]          -0.11661     0.1912 -0.6099\ndistance_abs_2:revenu≥2500                 0.14320     0.1780  0.8046\nSexWomen:revenu[1000-1499]                 0.04886     0.2999  0.1629\nSexWomen:revenu[1500-2499]                -0.06160     0.2701 -0.2280\nSexWomen:revenu≥2500                       0.07601     0.2558  0.2971\ndistance_abs_2:SexWomen:revenu[1000-1499] -0.09139     0.2959 -0.3089\ndistance_abs_2:SexWomen:revenu[1500-2499]  0.03572     0.2659  0.1343\ndistance_abs_2:SexWomen:revenu≥2500       -0.32040     0.2501 -1.2813\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -1.3544  0.1766    -7.6705\nMedium|High -0.1353  0.1759    -0.7691\n\nResidual Deviance: 17140.82 \nAIC: 17174.82 \n\n\ncode R\n# 6. Calculer les probabilités pour chaque niveau de satisfaction par sexe et revenu\npred_prob_clean_sex_revenu &lt;- predict(model_clean_sex_revenu, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_high &lt;- pred_prob_clean_sex_revenu[, \"High\"]\nmy_data_frame_clean$prob_medium &lt;- pred_prob_clean_sex_revenu[, \"Medium\"]\nmy_data_frame_clean$prob_low &lt;- pred_prob_clean_sex_revenu[, \"Low\"]\n\np &lt;- ggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_high, color = \"High\"), size = 1) +\n  geom_line(aes(y = prob_medium, color = \"Medium\"), size = 1) +\n  geom_line(aes(y = prob_low, color = \"Low\"), size = 1) +\n  labs(title = \"Probabilité d'être satisfait selon l'écart aux normes, par Sexe et Revenu\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"High\" = \"blue\", \"Medium\" = \"orange\", \"Low\" = \"red\")) +\n  theme_minimal() +\n  facet_grid(revenu ~ Sex) +  # Facet verticalement par revenu et horizontalement par sexe\n  theme(\n    legend.title = element_blank(),\n    strip.text.y = element_text(size = 10),  # Réduire la taille des labels des facettes\n    panel.spacing = unit(2, \"lines\")  # Augmenter l'espacement vertical entre facettes\n  )\n\n# Rendre interactif\np_interactive &lt;- ggplotly(p)\n\n# Afficher le graphique\np_interactive\n\n\n\n\n\n\n\n\ncode R\n# Charger les librairies nécessaires\nlibrary(MASS)\nlibrary(ggplot2)\nlibrary(plotly)\n\n\n\n# Supprimer les lignes contenant des valeurs manquantes dans les colonnes pertinentes\nmy_data_frame_clean &lt;- my_data_frame[complete.cases(my_data_frame[c(\"Santé\", \"Sex\", \"distance_abs_2\", \"revenu\")]), ]\n\n# Convertir les variables catégoriques en facteurs avec les niveaux appropriés\nmy_data_frame_clean$Sex &lt;- factor(my_data_frame_clean$Sex, levels = c(\"Men\", \"Women\"))\n\nmy_data_frame_clean$revenu &lt;- factor(my_data_frame_clean$revenu, \n                                     levels = c(\"Moins de 1000 euros\", \"1000 à 1499 euros\", \n                                                \"1500 à 2499 euros\", \"2500 euros et plus\"),\n                                     labels = c(\"&lt;1000\", \"[1000-1499]\", \"[1500-2499]\", \"≥2500\"))\n\n# Ajuster le modèle de régression logistique ordinale avec interaction entre Sexe, revenu et distance_abs_2\nmodel_clean_sex_revenu &lt;- polr(Santé ~ distance_abs_2 * Sex * revenu, \n                               data = my_data_frame_clean, method = \"logistic\")\n\n# Résumé du modèle\nsummary(model_clean_sex_revenu)\n\n\nCall:\npolr(formula = Santé ~ distance_abs_2 * Sex * revenu, data = my_data_frame_clean, \n    method = \"logistic\")\n\nCoefficients:\n                                             Value Std. Error t value\ndistance_abs_2                            -0.07229     0.1772 -0.4079\nSexWomen                                   0.02646     0.2401  0.1102\nrevenu[1000-1499]                         -0.17956     0.2341 -0.7672\nrevenu[1500-2499]                         -0.61613     0.2096 -2.9391\nrevenu≥2500                               -1.35968     0.2034 -6.6848\ndistance_abs_2:SexWomen                    0.09937     0.2390  0.4157\ndistance_abs_2:revenu[1000-1499]          -0.08366     0.2352 -0.3558\ndistance_abs_2:revenu[1500-2499]          -0.20282     0.2118 -0.9578\ndistance_abs_2:revenu≥2500                -0.11564     0.2024 -0.5713\nSexWomen:revenu[1000-1499]                 0.09874     0.3086  0.3199\nSexWomen:revenu[1500-2499]                -0.29406     0.2841 -1.0349\nSexWomen:revenu≥2500                      -0.07925     0.2746 -0.2886\ndistance_abs_2:SexWomen:revenu[1000-1499] -0.11806     0.3100 -0.3809\ndistance_abs_2:SexWomen:revenu[1500-2499]  0.26781     0.2862  0.9357\ndistance_abs_2:SexWomen:revenu≥2500        0.15741     0.2737  0.5750\n\nIntercepts:\n          Value   Std. Error t value\nGood|Fair -0.0474  0.1802    -0.2629\nFair|Poor  1.5620  0.1821     8.5795\n\nResidual Deviance: 12216.75 \nAIC: 12250.75 \n\n\ncode R\n# Calculer les probabilités pour chaque niveau de santé par sexe et revenu\npred_prob_clean_sex_revenu &lt;- predict(model_clean_sex_revenu, type = \"probs\")\n\n# Ajouter les probabilités au dataframe nettoyé\nmy_data_frame_clean$prob_high &lt;- pred_prob_clean_sex_revenu[, \"Good\"]\nmy_data_frame_clean$prob_medium &lt;- pred_prob_clean_sex_revenu[, \"Fair\"]\nmy_data_frame_clean$prob_low &lt;- pred_prob_clean_sex_revenu[, \"Poor\"]\n\n# Visualisation avec ggplot\np &lt;- ggplot(my_data_frame_clean, aes(x = distance_abs_2)) +\n  geom_line(aes(y = prob_high, color = \"High\"), size = 1) +\n  geom_line(aes(y = prob_medium, color = \"Medium\"), size = 1) +\n  geom_line(aes(y = prob_low, color = \"Low\"), size = 1) +\n  labs(title = \"Probabilité d'avoir un bon état de santé selon l'écart aux normes, par Sexe et Revenu\",\n       x = \"Distance aux Normes (Z-score)\",\n       y = \"Probabilité\") +\n  scale_color_manual(values = c(\"High\" = \"blue\", \"Medium\" = \"orange\", \"Low\" = \"red\")) +\n  theme_minimal() +\n  facet_grid(revenu ~ Sex) +  # Facet verticalement par revenu et horizontalement par sexe\n  theme(\n    legend.title = element_blank(),\n    strip.text.y = element_text(size = 10),  # Réduire la taille des labels des facettes\n    panel.spacing = unit(2, \"lines\")  # Augmenter l'espacement vertical entre facettes\n  )\n\n# Rendre interactif\np_interactive &lt;- ggplotly(p)\n\n# Afficher le graphique\np_interactive\n\n\n\n\n\n\n\n\ncode R\nmy_data_frame$distance_abs_2_bins&lt;-as.factor(my_data_frame$distance_abs_2_bins)\nmy_data_frame$satisfaction&lt;-as.factor(my_data_frame$satisfaction)\nrego &lt;- MASS::polr(\n  satisfaction ~ Sex + revenu + age_group + distance_abs_2_bins,\n  data = my_data_frame\n)\n\ntheme_gtsummary_language(\"en\", decimal.mark = \",\")\nrego |&gt; \n  tbl_regression(\n    exponentiate = TRUE,\n    tidy_fun = broom.helpers::tidy_parameters\n  ) |&gt; \n  bold_labels() |&gt; \n  add_global_p(keep = TRUE) |&gt; \n  as_kable_extra(format = \"latex\", booktabs = TRUE) |&gt; \n  kable_styling(latex_options = c(\"hold_position\", \"scale_down\"), full_width = FALSE)\n\n\n\n\n\ncode R\nrego |&gt; \n  ggstats::ggcoef_table(\n    exponentiate = TRUE,\n    tidy_fun = broom.helpers::tidy_parameters\n  )\n\n\n\n\n\n\n\n\n\ncode R\nrego |&gt; \n  broom.helpers::plot_marginal_predictions() |&gt; \n  patchwork::wrap_plots(ncol = 1) &\n  scale_y_continuous(labels = scales::percent) &\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\n\n# Vérifier et nettoyer la colonne Sex\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(\n    Sex = trimws(as.character(Sex)),  # Supprime les espaces autour des valeurs\n    Sex = case_when(\n      tolower(Sex) == \"men\" ~ \"Men\",   # Uniformise \"men\" en \"Men\"\n      tolower(Sex) == \"women\" ~ \"Women\",  # Uniformise \"women\" en \"Women\"\n      TRUE ~ NA_character_  # Remplace toutes les autres valeurs par NA\n    )\n  ) %&gt;%\n  drop_na(Sex)  # Supprime les lignes où Sex est NA\n\n# Séparer les données\ndf_men &lt;- my_data_frame %&gt;% filter(Sex == \"Men\")\ndf_women &lt;- my_data_frame %&gt;% filter(Sex == \"Women\")\n\n# Vérifier la séparation\nprint(dim(df_men))   # Nombre de lignes et colonnes pour les hommes\n\n\n[1] 4162 1593\n\n\ncode R\nprint(dim(df_women)) # Nombre de lignes et colonnes pour les femmes\n\n\n[1] 5072 1593\n\n\ncode R\n# Modèles de régression\nrego_men &lt;- polr(\n  satisfaction ~ revenu + age_group + score_scale,\n  data = df_men\n)\n\n\n\n# Fonction pour générer le tableau\ngenerate_table &lt;- function(rego_model) {\n  rego_model |&gt; \n    tbl_regression(\n      exponentiate = TRUE,\n      tidy_fun = broom.helpers::tidy_parameters\n    ) |&gt; \n    bold_labels() |&gt; \n    add_global_p(keep = TRUE) |&gt; \n    as_kable_extra(format = \"latex\", booktabs = TRUE) |&gt; \n    kable_styling(latex_options = c(\"hold_position\", \"scale_down\"), full_width = FALSE)\n}\n\np1&lt;- rego_men |&gt; \n  ggstats::ggcoef_table(\n    exponentiate = TRUE,\n    tidy_fun = broom.helpers::tidy_parameters\n  )\n\np1\n\n\n\n\n\n\n\n\n\ncode R\np2&lt;-rego_men |&gt; \n  broom.helpers::plot_marginal_predictions() |&gt; \n  patchwork::wrap_plots(ncol = 1) &\n  scale_y_continuous(labels = scales::percent) &\n  coord_flip()\np2\n\n\n\n\n\n\n\n\n\ncode R\ndf_women &lt;- df_women %&gt;%\n  mutate(across(where(is.factor), droplevels))\nrego_women &lt;- polr(\n  satisfaction ~ revenu + age_group + score_scale,\n  data = df_women\n)\n\nsummary(rego_women)\n\n\nCall:\npolr(formula = satisfaction ~ revenu + age_group + score_scale, \n    data = df_women)\n\nCoefficients:\n                           Value Std. Error  t value\nrevenu1000 à 1499 euros   0.2604    0.11542   2.2566\nrevenu1500 à 2499 euros   0.4406    0.10790   4.0832\nrevenu2500 euros et plus  0.5379    0.10226   5.2603\nage_group[38-54[         -0.2421    0.07518  -3.2199\nage_group[54-67[         -0.8566    0.07840 -10.9250\nage_group[67-97[         -1.8190    0.11709 -15.5350\nscore_scale2             -0.2358    0.47205  -0.4995\nscore_scale3             -0.2969    0.46379  -0.6402\nscore_scale4             -0.1785    0.46406  -0.3847\nscore_scale5             -0.2060    0.46711  -0.4410\nscore_scaleVery Feminine -0.1623    0.49138  -0.3302\n\nIntercepts:\n           Value    Std. Error t value \nHigh|Low    -1.1607   0.4724    -2.4567\nLow|Medium   0.6977   0.4721     1.4778\n\nResidual Deviance: 9113.95 \nAIC: 9139.95 \n(682 observations effacées parce que manquantes)\n\n\ncode R\np3&lt;-rego_women |&gt; \n  ggstats::ggcoef_table(\n    exponentiate = TRUE,\n    tidy_fun = broom.helpers::tidy_parameters\n  )\np3\n\n\n\n\n\n\n\n\n\ncode R\np4&lt;-rego_women |&gt; \n  broom.helpers::plot_marginal_predictions() |&gt; \n  patchwork::wrap_plots(ncol = 1) &\n  scale_y_continuous(labels = scales::percent) &\n  coord_flip()\n\np4\n\n\n\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(revenu, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(revenu) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~revenu, \n               y = ~proportion, \n               color = ~score_scale, \n               type = \"bar\",\n               text = ~paste0(round(proportion*100, 1), \"%\"), \n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par tranche de revenu\",\n         xaxis = list(title = \"Tranche de revenu\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\")  # Empilement des barres\n\nfig  # Affichage du graphique interactif\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(CLASSIF, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(CLASSIF) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~CLASSIF, \n               y = ~proportion, \n               color = ~score_scale, \n               type = \"bar\",\n               text = ~paste0(round(proportion*100, 1), \"%\"), \n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par profession\",\n         xaxis = list(title = \"Profession\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\")  # Empilement des barres\n\nfig  # Affichage du graphique interactif\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\nManoeuvre ou ouvrier spécialisé\n\n\n2\nOuvrier qualifié ou hautement qualifié/ technicien(ne) d’atelier\n\n\n3\nTechnicien(ne)\n\n\n4\nAgent de maîtrise, maîtrise administrative ou commerciale, VRP (non cadre)\n\n\n5\nIngénieur, Cadre\n\n\n6\nEmployé(e) de bureau, Employé(e) de commerce, Personnel de services\n\n\n7\nDirecteur général, Adjoint direct\n\n\n8\nNSP\n\n\n9\nREF\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(satisfaction, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(satisfaction) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~satisfaction, \n               y = ~proportion, \n               color = ~score_scale, \n               type = \"bar\",\n               text = ~paste0(round(proportion*100, 1), \"%\"), \n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par degré de satisfaction\",\n         xaxis = list(title = \"Satisfaction\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\")  # Empilement des barres\n\nfig  # Affichage du graphique interactif\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Convertir DIPLOM en facteur\nmy_data_frame$DIPLOM &lt;- as.factor(my_data_frame$DIPLOM)\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(DIPLOM, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(DIPLOM) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Ajouter une colonne avec les descriptions des diplômes\ndiplome_labels &lt;- c(\n  \"Vous n'avez jamais été à l'école ou vous l'avez quittée avant la fin du primaire\",\n  \"Aucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\",\n  \"Aucun diplôme et scolarité jusqu'à la fin du collège et au-delà\",\n  \"CEP\",\n  \"BEPC, brevet élémentaire, brevet des collèges, DNB\",\n  \"CAP, BEP ou diplôme équivalent\",\n  \"Baccalauréat général ou technologique, brevet supérieur\",\n  \"Capacité en droit, DAEU, ESEU\",\n  \"Baccalauréat professionnel, brevet professionnel, de technicien ou d'enseignement, diplôme équivalent\",\n  \"BTS, DUT, DEUST, diplôme de la santé ou social de niveau Bac+2 ou diplôme équivalent\",\n  \"Licence, licence pro, maîtrise ou autre diplôme de niveau Bac+3 ou 4 ou diplôme équivalent\",\n  \"Master, DEA, DESS, diplôme grande école de niveau Bac+5, doctorat de santé\",\n  \"Doctorat de recherche (hors santé)\",\n  \"NSP\",\n  \"REF\"\n)\n\n# Ajouter les libellés des diplômes à df_proportions\ndf_proportions &lt;- df_proportions %&gt;%\n  mutate(DIPLOM_label = diplome_labels[as.numeric(DIPLOM)])\n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~DIPLOM, \n               y = ~proportion, \n               color = ~score_scale, \n               type = \"bar\",\n               text = ~paste(DIPLOM_label, \"&lt;br&gt;\", round(proportion*100, 1), \"%\"),  # Affichage du libellé et proportion\n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par niveau de diplôme\",\n         xaxis = list(title = \"Niveau de diplôme\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\nfig\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Convertir DIPLOM en facteur\nmy_data_frame$DIPLOM &lt;- as.factor(my_data_frame$DIPLOM)\n# Création des quartiles de distance_abs_2\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(quartile_distance = cut(distance_abs_2, \n                                 breaks = quantile(distance_abs_2, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), \n                                 include.lowest = TRUE, \n                                 labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\")))  # Étiquettes des quartiles\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(DIPLOM, quartile_distance) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(DIPLOM) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Ajouter une colonne avec les descriptions des diplômes\ndiplome_labels &lt;- c(\n  \"Vous n'avez jamais été à l'école ou vous l'avez quittée avant la fin du primaire\",\n  \"Aucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\",\n  \"Aucun diplôme et scolarité jusqu'à la fin du collège et au-delà\",\n  \"CEP\",\n  \"BEPC, brevet élémentaire, brevet des collèges, DNB\",\n  \"CAP, BEP ou diplôme équivalent\",\n  \"Baccalauréat général ou technologique, brevet supérieur\",\n  \"Capacité en droit, DAEU, ESEU\",\n  \"Baccalauréat professionnel, brevet professionnel, de technicien ou d'enseignement, diplôme équivalent\",\n  \"BTS, DUT, DEUST, diplôme de la santé ou social de niveau Bac+2 ou diplôme équivalent\",\n  \"Licence, licence pro, maîtrise ou autre diplôme de niveau Bac+3 ou 4 ou diplôme équivalent\",\n  \"Master, DEA, DESS, diplôme grande école de niveau Bac+5, doctorat de santé\",\n  \"Doctorat de recherche (hors santé)\",\n  \"NSP\",\n  \"REF\"\n)\n\n# Ajouter les libellés des diplômes à df_proportions\ndf_proportions &lt;- df_proportions %&gt;%\n  mutate(DIPLOM_label = diplome_labels[as.numeric(DIPLOM)])\n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~DIPLOM, \n               y = ~proportion, \n               color = ~quartile_distance, \n               type = \"bar\",\n               text = ~paste(DIPLOM_label, \"&lt;br&gt;\", round(proportion*100, 1), \"%\"),  # Affichage du libellé et proportion\n               textposition = \"inside\") %&gt;%\n  layout(title = \"Quartile Distance par niveau de diplôme\",\n         xaxis = list(title = \"Niveau de diplôme\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\nfig\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Création des quartiles de distance_abs_2\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(quartile_distance = cut(distance_abs_2, \n                                 breaks = quantile(distance_abs_2, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), \n                                 include.lowest = TRUE, \n                                 labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\")))  # Étiquettes des quartiles\n\ntable(my_data_frame$quartile_distance)  # Vérification\n\n\n\n  Q1   Q2   Q3   Q4 \n2309 2308 2308 2309 \n\n\ncode R\n# Calcul des proportions correctes par satisfaction (A2)\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(satisfaction, quartile_distance) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(satisfaction) %&gt;%  # Normalisation par A2 et non par quartile_distance\n  mutate(proportion = count / sum(count))  \n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~satisfaction, \n               y = ~proportion, \n               color = ~quartile_distance, \n               type = \"bar\",\n               text = ~paste0(round(proportion * 100, 1), \"%\"), \n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de distance aux normes par degré de satisfaction\",\n         xaxis = list(title = \"Satisfaction\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\")  # Empilement des barres pour que chaque A2 fasse 100%\n\nfig\n\n\n\n\n\n\ncode R\n# Créer un tableau de contingence\ncontingency_table &lt;- table(my_data_frame$satisfaction, my_data_frame$quartile_distance)\n\n# Test du chi-deux\nchi2_test &lt;- chisq.test(contingency_table)\n\n# Résultats\nchi2_test\n\n\n\n    Pearson's Chi-squared test\n\ndata:  contingency_table\nX-squared = 11.811, df = 6, p-value = 0.06633\n\n\n\n\ncode R\ncontingency_table &lt;- table(my_data_frame$satisfaction, my_data_frame$quartile_distance)\nprint(contingency_table)\n\n\n        \n          Q1  Q2  Q3  Q4\n  High   785 779 823 730\n  Low    848 869 861 925\n  Medium 674 657 621 653\n\n\ncode R\nlibrary(nnet)\n\nmy_data_frame$satisfaction &lt;- as.factor(my_data_frame$satisfaction)  # S'assurer que A2 est factorielle\nmy_data_frame$quartile_distance &lt;- as.factor(my_data_frame$quartile_distance)  # Idem\n\nmodel &lt;- multinom(satisfaction ~ quartile_distance, data = my_data_frame)\n\n\n# weights:  15 (8 variable)\ninitial  value 10134.698363 \niter  10 value 10062.232209\nfinal  value 10062.112229 \nconverged\n\n\ncode R\nsummary(model)\n\n\nCall:\nmultinom(formula = satisfaction ~ quartile_distance, data = my_data_frame)\n\nCoefficients:\n       (Intercept) quartile_distanceQ2 quartile_distanceQ3 quartile_distanceQ4\nLow     0.07719688          0.03213488         -0.03205884          0.15955098\nMedium -0.15245629         -0.01787090         -0.12916843          0.04098897\n\nStd. Errors:\n       (Intercept) quartile_distanceQ2 quartile_distanceQ3 quartile_distanceQ4\nLow     0.04952907          0.06991118          0.06949558          0.07002909\nMedium  0.05251254          0.07458776          0.07471907          0.07522514\n\nResidual Deviance: 20124.22 \nAIC: 20140.22 \n\n\ncode R\nlibrary(ggeffects)\npred &lt;- ggeffect(model, terms = \"quartile_distance\")\nplot(pred)  # Visualisation des probabilités",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#diplomes-et-distance-aux-normes-de-genre",
    "href": "construction_indice.html#diplomes-et-distance-aux-normes-de-genre",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.4 Diplomes et distance aux normes de genre",
    "text": "1.4 Diplomes et distance aux normes de genre\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Convertir DIPLOM et Sex en facteurs\nmy_data_frame$DIPLOM &lt;- as.factor(my_data_frame$DIPLOM)\nmy_data_frame$Sex &lt;- as.factor(my_data_frame$Sex)\n\n# Création des quartiles de distance_abs_2\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(quartile_distance = cut(distance_abs_2, \n                                 breaks = quantile(distance_abs_2, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), \n                                 include.lowest = TRUE, \n                                 labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\")))  # Étiquettes des quartiles\n\n# Créer un tableau de proportions\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(Sex, DIPLOM, quartile_distance) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Sex, DIPLOM) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n# Ajouter une colonne avec les descriptions des diplômes\ndiplome_labels &lt;- c(\n  \"Vous n'avez jamais été à l'école ou vous l'avez quittée avant la fin du primaire\",\n  \"Aucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\",\n  \"Aucun diplôme et scolarité jusqu'à la fin du collège et au-delà\",\n  \"CEP\",\n  \"BEPC, brevet élémentaire, brevet des collèges, DNB\",\n  \"CAP, BEP ou diplôme équivalent\",\n  \"Baccalauréat général ou technologique, brevet supérieur\",\n  \"Capacité en droit, DAEU, ESEU\",\n  \"Baccalauréat professionnel, brevet professionnel, de technicien ou d'enseignement, diplôme équivalent\",\n  \"BTS, DUT, DEUST, diplôme de la santé ou social de niveau Bac+2 ou diplôme équivalent\",\n  \"Licence, licence pro, maîtrise ou autre diplôme de niveau Bac+3 ou 4 ou diplôme équivalent\",\n  \"Master, DEA, DESS, diplôme grande école de niveau Bac+5, doctorat de santé\",\n  \"Doctorat de recherche (hors santé)\",\n  \"NSP\",\n  \"REF\"\n)\n\n# Ajouter les libellés des diplômes à df_proportions\ndf_proportions &lt;- df_proportions %&gt;%\n  mutate(DIPLOM_label = diplome_labels[as.numeric(DIPLOM)])\n\n# Séparer les données en deux sous-ensembles (Hommes et Femmes)\ndf_men &lt;- df_proportions %&gt;% filter(Sex == \"Men\")\ndf_women &lt;- df_proportions %&gt;% filter(Sex == \"Women\")\n\n# Graphique pour les hommes\nfig_men &lt;- plot_ly(df_men, \n                   x = ~DIPLOM, \n                   y = ~proportion, \n                   color = ~quartile_distance, \n                   type = \"bar\",\n                   text = ~paste(DIPLOM_label, \"&lt;br&gt;\", round(proportion*100, 1), \"%\"),  # Affichage du libellé et proportion\n                   textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par niveau de diplôme (Hommes)\",\n         xaxis = list(title = \"Niveau de diplôme\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\n# Graphique pour les femmes\nfig_women &lt;- plot_ly(df_women, \n                     x = ~DIPLOM, \n                     y = ~proportion, \n                     color = ~quartile_distance, \n                     type = \"bar\",\n                     text = ~paste(DIPLOM_label, \"&lt;br&gt;\", round(proportion*100, 1), \"%\"),  # Affichage du libellé et proportion\n                     textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par niveau de diplôme (Femmes)\",\n         xaxis = list(title = \"Niveau de diplôme\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\n# Afficher les deux graphiques séparés\nfig_men\n\n\n\n\n\n\ncode R\nfig_women\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n# Création des quartiles de distance_abs_2\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(quartile_distance = cut(distance_abs_2, \n                                 breaks = quantile(distance_abs_2, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE), \n                                 include.lowest = TRUE, \n                                 labels = c(\"Q1\", \"Q2\", \"Q3\", \"Q4\")))  # Étiquettes des quartiles\n\ntable(my_data_frame$quartile_distance)  # Vérification\n\n\n\n  Q1   Q2   Q3   Q4 \n2309 2308 2308 2309 \n\n\ncode R\n# Calcul des proportions correctes par satisfaction (A2)\ndf_proportions &lt;- my_data_frame %&gt;%\n  group_by(Santé, quartile_distance) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Santé) %&gt;%  # Normalisation par A2 et non par quartile_distance\n  mutate(proportion = count / sum(count))  \n\n# Graphique interactif avec Plotly (barres empilées)\nfig &lt;- plot_ly(df_proportions, \n               x = ~Santé, \n               y = ~proportion, \n               color = ~quartile_distance, \n               type = \"bar\",\n               text = ~paste0(round(proportion * 100, 1), \"%\"), \n               textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de distance aux normes par état de Santé\",\n         xaxis = list(title = \"Santé\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\")  # Empilement des barres pour que chaque A2 fasse 100%\n\nfig\n\n\n\n\n\n\ncode R\n# Créer un tableau de contingence\ncontingency_table &lt;- table(my_data_frame$Santé, my_data_frame$quartile_distance)\n\n# Test du chi-deux\nchi2_test &lt;- chisq.test(contingency_table)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#comparaison-des-modèles-suite",
    "href": "construction_indice.html#comparaison-des-modèles-suite",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.5 Comparaison des modèles (Suite)",
    "text": "1.5 Comparaison des modèles (Suite)\n\n\ncode R\nmy_data_frame$Sex &lt;- as.factor(my_data_frame$Sex)\n\n# Modèle avec 'identity'\nmodel_identity &lt;- glm(Sex ~ identity, data = my_data_frame, family = binomial)\n\n# Modèle avec 'score'\nmodel_score &lt;- glm(Sex ~ score, data = my_data_frame, family = binomial)\n\n# Comparer les modèles via les critères AIC (Akaike Information Criterion)\naic_identity &lt;- AIC(model_identity)\naic_score &lt;- AIC(model_score)\n\n# Comparer les modèles via la deviance\ndeviance_identity &lt;- deviance(model_identity)\ndeviance_score &lt;- deviance(model_score)\n\n# Résumé des modèles\nsummary(model_identity)\n\n\n\nCall:\nglm(formula = Sex ~ identity, family = binomial, data = my_data_frame)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)  3.00930    0.08534   35.26   &lt;2e-16 ***\nidentity    -7.59704    0.22373  -33.96   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 12711  on 9233  degrees of freedom\nResidual deviance: 11162  on 9232  degrees of freedom\nAIC: 11166\n\nNumber of Fisher Scoring iterations: 4\n\n\ncode R\nsummary(model_score)\n\n\n\nCall:\nglm(formula = Sex ~ score, family = binomial, data = my_data_frame)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept) -0.58503    0.03010  -19.43   &lt;2e-16 ***\nscore        1.04195    0.02254   46.22   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 12711.2  on 9233  degrees of freedom\nResidual deviance:  8323.5  on 9232  degrees of freedom\nAIC: 8327.5\n\nNumber of Fisher Scoring iterations: 5\n\n\ncode R\n# Affichage des AIC et deviance\ncat(\"AIC for model with 'identity':\", aic_identity, \"\\n\")\n\n\nAIC for model with 'identity': 11166.46 \n\n\ncode R\ncat(\"AIC for model with 'score':\", aic_score, \"\\n\")\n\n\nAIC for model with 'score': 8327.457 \n\n\ncode R\ncat(\"Deviance for model with 'identity':\", deviance_identity, \"\\n\")\n\n\nDeviance for model with 'identity': 11162.46 \n\n\ncode R\ncat(\"Deviance for model with 'score':\", deviance_score, \"\\n\")\n\n\nDeviance for model with 'score': 8323.457 \n\n\n\n\ncode R\nlibrary(pROC)\n\n# Calculer la probabilité prédite pour chaque modèle\nprob_identity &lt;- predict(model_identity, type = \"response\")\nprob_score &lt;- predict(model_score, type = \"response\")\n\n# Calculer la courbe ROC et AUC pour chaque modèle\nroc_identity &lt;- roc(my_data_frame$Sex, prob_identity)\nroc_score &lt;- roc(my_data_frame$Sex, prob_score)\n\n# Afficher les résultats AUC\ncat(\"AUC for model with 'identity':\", auc(roc_identity), \"\\n\")\n\n\nAUC for model with 'identity': 0.7242187 \n\n\ncode R\ncat(\"AUC for model with 'score':\", auc(roc_score), \"\\n\")\n\n\nAUC for model with 'score': 0.8676684 \n\n\ncode R\n# Tracer les courbes ROC\nplot(roc_identity, col = \"blue\", main = \"Courbes ROC pour 'identity' et 'score'\")\nplot(roc_score, col = \"red\", add = TRUE)\nlegend(\"bottomright\", legend = c(\"identity\", \"score\"), col = c(\"blue\", \"red\"), lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\ncode R\n# Convertir satisfaction en numérique\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(satisfaction_numeric = case_when(\n    satisfaction == \"Low\" ~ 1,\n    satisfaction == \"Medium\" ~ 2,\n    satisfaction == \"High\" ~ 3,\n    TRUE ~ NA_real_  # Gérer les valeurs manquantes si nécessaire\n  ))\n\n# Vérifier la conversion\ntable(my_data_frame$satisfaction_numeric)\n\n\n\n   1    2    3 \n3503 2605 3117 \n\n\ncode R\n# Test de corrélation de Spearman entre satisfaction (ordinale) et distance_quartile (continue)\ncor.test(my_data_frame$satisfaction_numeric, my_data_frame$distance_abs_2, method = \"spearman\")\n\n\n\n    Spearman's rank correlation rho\n\ndata:  my_data_frame$satisfaction_numeric and my_data_frame$distance_abs_2\nS = 1.3324e+11, p-value = 0.07856\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n        rho \n-0.01831584 \n\n\ncode R\n# Convertir 'santé' en numérique (Good = 1, Fair = 2, Poor = 3)\nmy_data_frame &lt;- my_data_frame %&gt;%\n  mutate(santé_numeric = case_when(\n    Santé == \"Good\" ~ 1,\n    Santé == \"Fair\" ~ 2,\n    Santé == \"Poor\" ~ 3,\n    TRUE ~ NA_real_\n  ))\n\n# Test de corrélation de Spearman entre santé (ordinale) et distance_abs_2\ncor.test(my_data_frame$santé_numeric, my_data_frame$distance_abs_2, method = \"spearman\")\n\n\n\n    Spearman's rank correlation rho\n\ndata:  my_data_frame$santé_numeric and my_data_frame$distance_abs_2\nS = 1.2994e+11, p-value = 0.6901\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n         rho \n-0.004159822 \n\n\n\n\ncode R\n# Régression logistique ordinale\nlibrary(MASS)\nrego_ordinal &lt;- polr(satisfaction ~ distance_abs_2, data = my_data_frame, method = \"logistic\")\nsummary(rego_ordinal)\n\n\nCall:\npolr(formula = satisfaction ~ distance_abs_2, data = my_data_frame, \n    method = \"logistic\")\n\nCoefficients:\n                 Value Std. Error t value\ndistance_abs_2 0.02273    0.03199  0.7105\n\nIntercepts:\n           Value    Std. Error t value \nHigh|Low    -0.6543   0.0340   -19.2524\nLow|Medium   0.9511   0.0348    27.3139\n\nResidual Deviance: 20135.53 \nAIC: 20141.53 \n(9 observations effacées parce que manquantes)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#sexe-ou-genre-pour-prédire-la-satisfaction",
    "href": "construction_indice.html#sexe-ou-genre-pour-prédire-la-satisfaction",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.6 Sexe ou Genre pour prédire la Satisfaction ?",
    "text": "1.6 Sexe ou Genre pour prédire la Satisfaction ?\n\n\ncode R\n# Convertir les variables en facteurs si nécessaire\nmy_data_frame$DIPLOM &lt;- as.factor(my_data_frame$DIPLOM)\nmy_data_frame$Sex &lt;- as.factor(my_data_frame$Sex)\nmy_data_frame$CLASSIF &lt;- as.factor(my_data_frame$CLASSIF)\nmy_data_frame$revenu &lt;- as.factor(my_data_frame$revenu)\nmy_data_frame$Santé &lt;- as.factor(my_data_frame$Santé)\nmy_data_frame$satisfaction &lt;- as.factor(my_data_frame$satisfaction)\nmy_data_frame$SITUA &lt;- as.factor(my_data_frame$SITUA)\nmy_data_frame$CS2D &lt;- as.factor(my_data_frame$CS2D)\n\n# Créer une fonction pour comparer les modèles avec 'score' et 'Sex' comme prédicteurs\ncompare_models &lt;- function(variable) {\n  # Affichage de la variable actuellement traitée\n  cat(\"Traitement de la variable :\", variable, \"\\n\")\n  \n  # Modèle avec score comme prédicteur\n  model_score &lt;- polr(as.formula(paste(variable, \"~ score_normalise_2\")), data = my_data_frame, method = \"logistic\")\n  \n  # Modèle avec sexe comme prédicteur\n  model_sex &lt;- polr(as.formula(paste(variable, \"~ Sex\")), data = my_data_frame, method = \"logistic\")\n  \n  # Comparer l'AIC des deux modèles\n  aic_score &lt;- AIC(model_score)\n  aic_sex &lt;- AIC(model_sex)\n  \n  # Comparer et retourner le meilleur modèle\n  if (aic_score &lt; aic_sex) {\n    return(data.frame(variable = variable, best_predictor = \"Score\", AIC_score = aic_score, AIC_sex = aic_sex))\n  } else {\n    return(data.frame(variable = variable, best_predictor = \"Sex\", AIC_score = aic_score, AIC_sex = aic_sex))\n  }\n}\n\n# Liste des variables d'intérêt à analyser\nvariables &lt;- c(\"DIPLOM\", \"CLASSIF\", \"SITUA\", \"satisfaction\", \"Santé\", \"revenu\", \"CS2D\")\n\n# Appliquer la fonction pour chaque variable d'intérêt et combiner les résultats\nresults &lt;- do.call(rbind, lapply(variables, compare_models))\n\n\nTraitement de la variable : DIPLOM \nTraitement de la variable : CLASSIF \nTraitement de la variable : SITUA \nTraitement de la variable : satisfaction \nTraitement de la variable : Santé \nTraitement de la variable : revenu \nTraitement de la variable : CS2D \n\n\ncode R\n# Afficher les résultats sous forme de tableau\nprint(results)\n\n\n      variable best_predictor AIC_score   AIC_sex\n1       DIPLOM          Score 41875.234 41877.259\n2      CLASSIF            Sex  9541.198  9303.852\n3        SITUA            Sex 24323.188 24316.900\n4 satisfaction            Sex 20141.821 20141.519\n5        Santé            Sex 14570.078 14563.140\n6       revenu            Sex 19741.506 19729.137\n7         CS2D          Score 29090.088 29114.292",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  },
  {
    "objectID": "construction_indice.html#genre-et-professions",
    "href": "construction_indice.html#genre-et-professions",
    "title": "1  Notre Mesure: Le Cultural Gender Normativity Index (CGNI)",
    "section": "1.7 Genre et Professions",
    "text": "1.7 Genre et Professions\n\n\ncode R\nlibrary(readxl)\nmy_data_frame$CS2D&lt;-as.numeric(my_data_frame$CS2D)\nListes_professions &lt;- read_excel(\"professions.xls\")\n\nmapping_codes_libelles &lt;- Listes_professions[, c(\"Code\", \"Libelle\")]\n\nmy_data_frame &lt;- my_data_frame %&gt;%\n  left_join(mapping_codes_libelles, by = c(\"CS2D\" = \"Code\")) %&gt;%\n  mutate(CS2D = Libelle)\n# Charger la bibliothèque dplyr pour manipuler les données\nlibrary(dplyr)\n\n\nhead(my_data_frame$CS2D)\n\n\n[1] \"Chefs d'entreprise de 10 salariés ou plus\"\n[2] NA                                         \n[3] \"Agriculteurs sur petite exploitation\"     \n[4] NA                                         \n[5] NA                                         \n[6] NA                                         \n\n\ncode R\nsummary(my_data_frame$CS2D)\n\n\n   Length     Class      Mode \n     9234 character character \n\n\ncode R\n# Compter les occurrences des professions\nprofession_counts &lt;- table(my_data_frame$CS2D)\n\n# Trier les professions par fréquence, du plus grand au plus petit\nprofession_counts_sorted &lt;- sort(profession_counts, decreasing = TRUE)\n\n# Sélectionner les 10 professions les plus représentées\ntop_10_professions &lt;- head(profession_counts_sorted, 10)\n\n# Afficher les 10 professions les plus représentées\ntop_10_professions\n\n\n\n                                                Artisans \n                                                     332 \n                                   Professions libérales \n                                                     228 \n                                Commerçants et assimilés \n                                                     219 \n                   Agriculteurs sur moyenne exploitation \n                                                     144 \n               Chefs d'entreprise de 10 salariés ou plus \n                                                     111 \n                    Agriculteurs sur petite exploitation \n                                                     105 \n                  Professeurs, professions scientifiques \n                                                      90 \nProfessions de l'information, des arts et des spectacles \n                                                      88 \n                    Agriculteurs sur grande exploitation \n                                                      79 \n                          Cadres de la fonction publique \n                                                      74 \n\n\ncode R\n# Filtrer les données pour ne garder que les 10 professions les plus représentées\ntop_10_data &lt;- my_data_frame[my_data_frame$CS2D %in% names(top_10_professions), ]\n\n# Créer un tableau de proportions\ntop_10_data &lt;- my_data_frame %&gt;%\n  group_by(Sex, CS2D, quartile_distance, score_normalise_2, distance_abs_2, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Sex, CS2D) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\n\n# Séparer les données en deux sous-ensembles (Hommes et Femmes)\ndf_men &lt;- top_10_data %&gt;% filter(Sex == \"Men\")\ndf_women &lt;- top_10_data %&gt;% filter(Sex == \"Women\")\n\n# Graphique pour les hommes\nfig_men &lt;- plot_ly(df_men, \n                   x = ~CS2D, \n                   y = ~proportion, \n                   color = ~quartile_distance, \n                   type = \"bar\",\n                     # Affichage du libellé et proportion\n                   textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par niveau de diplôme (Hommes)\",\n         xaxis = list(title = \"profession\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\n# Graphique pour les femmes\nfig_women &lt;- plot_ly(df_women, \n                     x = ~CS2D, \n                     y = ~proportion, \n                     color = ~quartile_distance, \n                     type = \"bar\",\n                       \n                     textposition = \"inside\") %&gt;%\n  layout(title = \"Proportion de score_scale par profession (Femmes)\",\n         xaxis = list(title = \"Profession\"),\n         yaxis = list(title = \"Proportion\", tickformat = \"%\"),\n         barmode = \"stack\",  # Empilement des barres\n         hovermode = \"closest\")  # Afficher les informations les plus proches du survol\n\n# Afficher les deux graphiques séparés\nfig_men\n\n\n\n\n\n\ncode R\nfig_women\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Vérifier que CS2D et Sex sont bien des facteurs\ntop_10_data$CS2D &lt;- as.factor(top_10_data$CS2D)\ntop_10_data$Sex &lt;- as.factor(top_10_data$Sex)\n\n# Calcul du score moyen par profession\nscore_summary &lt;- top_10_data %&gt;%\n  group_by(CS2D) %&gt;%\n  summarise(score_moyen = mean(score_normalise_2, na.rm = TRUE))\n\n# Calcul des proportions Homme/Femme par profession\nsex_distribution &lt;- top_10_data %&gt;%\n  group_by(CS2D, Sex) %&gt;%\n  summarise(n = n(), .groups = \"drop\") %&gt;%\n  group_by(CS2D) %&gt;%\n  mutate(proportion = n / sum(n))\n\n# Fusionner les deux datasets\nsummary_data &lt;- left_join(score_summary, sex_distribution, by = \"CS2D\")\n\n# Visualisation combinée\nggplot(summary_data, aes(x = reorder(CS2D, score_moyen))) +\n  geom_col(aes(y = score_moyen), fill = \"blue\", alpha = 0.6) +\n  geom_point(aes(y = proportion * max(score_moyen), color = Sex), size = 4) +\n  scale_y_continuous(\n    sec.axis = sec_axis(~./max(score_summary$score_moyen), name = \"Proportion H/F\")\n  ) +\n  labs(title = \"Score moyen et proportion H/F par profession\",\n       x = \"Profession (CS2D)\", y = \"Score normalisé moyen\") +\n  coord_flip() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Vérifier que CS2D et Sex sont bien des facteurs\ntop_10_data$CS2D &lt;- as.factor(top_10_data$CS2D)\ntop_10_data$Sex &lt;- as.factor(top_10_data$Sex)\n\n# Calcul du score moyen par profession\ndistance_summary &lt;- top_10_data %&gt;%\n  group_by(CS2D) %&gt;%\n  summarise(distance_moyenne = mean(distance_abs_2, na.rm = TRUE))\n\n# Calcul des proportions Homme/Femme par profession\nsex_distribution &lt;- top_10_data %&gt;%\n  group_by(CS2D, Sex) %&gt;%\n  summarise(n = n(), .groups = \"drop\") %&gt;%\n  group_by(CS2D) %&gt;%\n  mutate(proportion = n / sum(n))\n\n# Fusionner les deux datasets\nsummary_data &lt;- left_join(distance_summary, sex_distribution, by = \"CS2D\")\n\n# Visualisation combinée\nggplot(summary_data, aes(x = reorder(CS2D, distance_moyenne))) +\n  geom_col(aes(y = distance_moyenne), fill = \"blue\", alpha = 0.6) +\n  geom_point(aes(y = proportion * max(distance_moyenne), color = Sex), size = 4) +\n  scale_y_continuous(\n    sec.axis = sec_axis(~./max(distance_summary$distance_moyenne), name = \"Proportion H/F\")\n  ) +\n  labs(title = \"Distance moyenne et proportion H/F par profession\",\n       x = \"Profession (CS2D)\", y = \"Distance moyenne\") +\n  coord_flip() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\ncode R\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Vérifier que CS2D et Sex sont bien des facteurs\ntop_10_data$CS2D &lt;- as.factor(top_10_data$CS2D)\ntop_10_data$Sex &lt;- as.factor(top_10_data$Sex)\n\n# Calcul de la distance moyenne par profession et par sexe\ndistance_summary &lt;- top_10_data %&gt;%\n  group_by(CS2D, Sex) %&gt;%\n  summarise(distance_moyenne = mean(distance_abs_2, na.rm = TRUE), .groups = \"drop\")\n\n# Visualisation\np&lt;-ggplot(distance_summary, aes(x = reorder(CS2D, distance_moyenne), y = distance_moyenne, fill = Sex)) +\n  geom_col(position = \"dodge\") +\n  labs(title = \"Distance moyenne (score_distance) par profession et par sexe\",\n       x = \"Profession (CS2D)\", y = \"Distance moyenne (score_distance)\") +\n  coord_flip() +\n  theme_minimal()\n\np_plotly&lt;-ggplotly(p)\np_plotly\n\n\n\n\n\n\n\n\ncode R\n# Créer un tableau de proportions\ntop_10_data &lt;- my_data_frame %&gt;%\n  group_by(Sex, CS2D, quartile_distance, score_normalise_2, distance_abs_2, score_scale) %&gt;%\n  summarise(count = n(), .groups = \"drop\") %&gt;%\n  group_by(Sex, CS2D) %&gt;%\n  mutate(proportion = count / sum(count))  # Calcul de la proportion\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\n\n# Vérifier que CS2D, Sex et score_scale sont bien des facteurs\ntop_10_data$CS2D &lt;- as.factor(top_10_data$CS2D)\ntop_10_data$Sex &lt;- as.factor(top_10_data$Sex)\ntop_10_data$score_scale &lt;- as.factor(top_10_data$score_scale)\n\n# Calcul des proportions de score_scale par profession et sexe\nscore_scale_distribution &lt;- top_10_data %&gt;%\n  group_by(CS2D, Sex, score_scale) %&gt;%\n  summarise(n = n(), .groups = \"drop\") %&gt;%\n  group_by(CS2D, Sex) %&gt;%\n  mutate(proportion = n / sum(n))\n\n# Visualisation\nggplot(score_scale_distribution, aes(x = score_scale, y = proportion, fill = Sex)) +\n  geom_col(position = \"dodge\") +\n  facet_wrap(~ CS2D) +\n  labs(title = \"Répartition de score_scale par profession et sexe\",\n       x = \"Score Scale\", y = \"Proportion\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\n\ncode R\ntop_10_data$CS2D &lt;- as.factor(top_10_data$CS2D)\ntop_10_data$Sex &lt;- as.factor(top_10_data$Sex)\ntop_10_data$score_scale &lt;- as.factor(top_10_data$score_scale)\n\n# Créer une version numérotée (1-10 + NA) pour affichage dans le graphique\ntop_10_data$CS2D_numeric &lt;- as.numeric(top_10_data$CS2D)\n\n# Calcul des proportions de score_scale par profession et sexe\nscore_scale_distribution &lt;- top_10_data %&gt;%\n  group_by(CS2D_numeric, CS2D, Sex, score_scale) %&gt;%\n  summarise(n = n(), .groups = \"drop\") %&gt;%\n  group_by(CS2D_numeric, CS2D, Sex) %&gt;%\n  mutate(proportion = n / sum(n))\n\n# Graphique ggplot\np &lt;- ggplot(score_scale_distribution, aes(x = score_scale, y = proportion, fill = Sex, \n                                          text = paste(\"Profession :\", CS2D))) +\n  geom_col(position = \"dodge\") +\n  facet_wrap(~ CS2D_numeric) +  # Garde les professions sous forme de codes\n  labs(title = \"Répartition de score_scale par profession et sexe\",\n       x = \"Score Scale\", y = \"Proportion\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# Convertir en ggplotly avec tooltip interactif\nggplotly(p, tooltip = \"text\")\n\n\n\n\n\n\n\n\ncode R\n# Créer une version numérotée (1-10 + NA) pour affichage dans le graphique\ntop_10_data$CS2D_numeric &lt;- as.numeric(top_10_data$CS2D)\n\n# Calcul des proportions de score_scale par profession et sexe\nscore_scale_distribution &lt;- top_10_data %&gt;%\n  group_by(CS2D_numeric, CS2D, Sex, score_scale) %&gt;%\n  summarise(n = n(), .groups = \"drop\") %&gt;%\n  group_by(CS2D_numeric, CS2D, Sex) %&gt;%\n  mutate(proportion = n / sum(n) * 100)  # Conversion en pourcentage\n\n# Graphique ggplot\np &lt;- ggplot(score_scale_distribution, aes(x = score_scale, y = proportion, fill = Sex, \n                                          text = paste(\"Profession :\", CS2D, \"&lt;br&gt;\",\n                                                       \"Sexe :\", Sex, \"&lt;br&gt;\",\n                                                       \"Proportion :\", round(proportion, 1), \"%\"))) +\n  geom_col(position = \"dodge\") +\n  facet_wrap(~ CS2D_numeric) +  # Garde les professions sous forme de codes\n  labs(title = \"Répartition de score_scale par profession et sexe\",\n       x = \"Score Scale\", y = \"Proportion (%)\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n\n# Convertir en ggplotly avec tooltip interactif\nggplotly(p, tooltip = \"text\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notre Mesure: Le Cultural Gender Normativity Index (CGNI)</span>"
    ]
  }
]